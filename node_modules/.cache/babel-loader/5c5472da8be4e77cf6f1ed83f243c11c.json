{"ast":null,"code":"import { RangePatternType } from '../types/date-time';\nimport { SameValue, TimeClip } from '../262';\nimport { ToLocalTime } from './ToLocalTime';\nimport { FormatDateTimePattern } from './FormatDateTimePattern';\nimport { PartitionPattern } from '../PartitionPattern';\nvar TABLE_2_FIELDS = ['era', 'year', 'month', 'day', 'ampm', 'hour', 'minute', 'second'];\nexport function PartitionDateTimeRangePattern(dtf, x, y, implDetails) {\n  x = TimeClip(x);\n\n  if (isNaN(x)) {\n    throw new RangeError('Invalid start time');\n  }\n\n  y = TimeClip(y);\n\n  if (isNaN(y)) {\n    throw new RangeError('Invalid end time');\n  }\n  /** IMPL START */\n\n\n  var getInternalSlots = implDetails.getInternalSlots,\n      tzData = implDetails.tzData;\n  var internalSlots = getInternalSlots(dtf);\n  /** IMPL END */\n\n  var tm1 = ToLocalTime(x, // @ts-ignore\n  internalSlots.calendar, internalSlots.timeZone, {\n    tzData: tzData\n  });\n  var tm2 = ToLocalTime(y, // @ts-ignore\n  internalSlots.calendar, internalSlots.timeZone, {\n    tzData: tzData\n  });\n  var pattern = internalSlots.pattern,\n      rangePatterns = internalSlots.rangePatterns;\n  var rangePattern;\n  var dateFieldsPracticallyEqual = true;\n  var patternContainsLargerDateField = false;\n\n  for (var _i = 0, TABLE_2_FIELDS_1 = TABLE_2_FIELDS; _i < TABLE_2_FIELDS_1.length; _i++) {\n    var fieldName = TABLE_2_FIELDS_1[_i];\n\n    if (dateFieldsPracticallyEqual && !patternContainsLargerDateField) {\n      if (fieldName === 'ampm') {\n        var rp = rangePatterns.ampm;\n\n        if (rangePattern !== undefined && rp === undefined) {\n          patternContainsLargerDateField = true;\n        } else {\n          var v1 = tm1.hour;\n          var v2 = tm2.hour;\n\n          if (v1 > 11 && v2 < 11 || v1 < 11 && v2 > 11) {\n            dateFieldsPracticallyEqual = false;\n          }\n\n          rangePattern = rp;\n        }\n      } else {\n        var rp = rangePatterns[fieldName];\n\n        if (rangePattern !== undefined && rp === undefined) {\n          patternContainsLargerDateField = true;\n        } else {\n          var v1 = tm1[fieldName];\n          var v2 = tm2[fieldName];\n\n          if (!SameValue(v1, v2)) {\n            dateFieldsPracticallyEqual = false;\n          }\n\n          rangePattern = rp;\n        }\n      }\n    }\n  }\n\n  if (dateFieldsPracticallyEqual) {\n    var result_2 = FormatDateTimePattern(dtf, PartitionPattern(pattern), x, implDetails);\n\n    for (var _a = 0, result_1 = result_2; _a < result_1.length; _a++) {\n      var r = result_1[_a];\n      r.source = RangePatternType.shared;\n    }\n\n    return result_2;\n  }\n\n  var result = [];\n\n  if (rangePattern === undefined) {\n    rangePattern = rangePatterns.default;\n    /** IMPL DETAILS */\n    // Now we have to replace {0} & {1} with actual pattern\n\n    for (var _b = 0, _c = rangePattern.patternParts; _b < _c.length; _b++) {\n      var patternPart = _c[_b];\n\n      if (patternPart.pattern === '{0}' || patternPart.pattern === '{1}') {\n        patternPart.pattern = pattern;\n      }\n    }\n  }\n\n  for (var _d = 0, _e = rangePattern.patternParts; _d < _e.length; _d++) {\n    var rangePatternPart = _e[_d];\n    var source = rangePatternPart.source,\n        pattern_1 = rangePatternPart.pattern;\n    var z = void 0;\n\n    if (source === RangePatternType.startRange || source === RangePatternType.shared) {\n      z = x;\n    } else {\n      z = y;\n    }\n\n    var patternParts = PartitionPattern(pattern_1);\n    var partResult = FormatDateTimePattern(dtf, patternParts, z, implDetails);\n\n    for (var _f = 0, partResult_1 = partResult; _f < partResult_1.length; _f++) {\n      var r = partResult_1[_f];\n      r.source = source;\n    }\n\n    result = result.concat(partResult);\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/zibranshaikh/Downloads/scaffoldzoid/frontend/node_modules/@formatjs/ecma402-abstract/lib/DateTimeFormat/PartitionDateTimeRangePattern.js"],"names":["RangePatternType","SameValue","TimeClip","ToLocalTime","FormatDateTimePattern","PartitionPattern","TABLE_2_FIELDS","PartitionDateTimeRangePattern","dtf","x","y","implDetails","isNaN","RangeError","getInternalSlots","tzData","internalSlots","tm1","calendar","timeZone","tm2","pattern","rangePatterns","rangePattern","dateFieldsPracticallyEqual","patternContainsLargerDateField","_i","TABLE_2_FIELDS_1","length","fieldName","rp","ampm","undefined","v1","hour","v2","result_2","_a","result_1","r","source","shared","result","default","_b","_c","patternParts","patternPart","_d","_e","rangePatternPart","pattern_1","z","startRange","partResult","_f","partResult_1","concat"],"mappings":"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","sourcesContent":["import { RangePatternType, } from '../types/date-time';\nimport { SameValue, TimeClip } from '../262';\nimport { ToLocalTime } from './ToLocalTime';\nimport { FormatDateTimePattern, } from './FormatDateTimePattern';\nimport { PartitionPattern } from '../PartitionPattern';\nvar TABLE_2_FIELDS = [\n    'era',\n    'year',\n    'month',\n    'day',\n    'ampm',\n    'hour',\n    'minute',\n    'second',\n];\nexport function PartitionDateTimeRangePattern(dtf, x, y, implDetails) {\n    x = TimeClip(x);\n    if (isNaN(x)) {\n        throw new RangeError('Invalid start time');\n    }\n    y = TimeClip(y);\n    if (isNaN(y)) {\n        throw new RangeError('Invalid end time');\n    }\n    /** IMPL START */\n    var getInternalSlots = implDetails.getInternalSlots, tzData = implDetails.tzData;\n    var internalSlots = getInternalSlots(dtf);\n    /** IMPL END */\n    var tm1 = ToLocalTime(x, \n    // @ts-ignore\n    internalSlots.calendar, internalSlots.timeZone, { tzData: tzData });\n    var tm2 = ToLocalTime(y, \n    // @ts-ignore\n    internalSlots.calendar, internalSlots.timeZone, { tzData: tzData });\n    var pattern = internalSlots.pattern, rangePatterns = internalSlots.rangePatterns;\n    var rangePattern;\n    var dateFieldsPracticallyEqual = true;\n    var patternContainsLargerDateField = false;\n    for (var _i = 0, TABLE_2_FIELDS_1 = TABLE_2_FIELDS; _i < TABLE_2_FIELDS_1.length; _i++) {\n        var fieldName = TABLE_2_FIELDS_1[_i];\n        if (dateFieldsPracticallyEqual && !patternContainsLargerDateField) {\n            if (fieldName === 'ampm') {\n                var rp = rangePatterns.ampm;\n                if (rangePattern !== undefined && rp === undefined) {\n                    patternContainsLargerDateField = true;\n                }\n                else {\n                    var v1 = tm1.hour;\n                    var v2 = tm2.hour;\n                    if ((v1 > 11 && v2 < 11) || (v1 < 11 && v2 > 11)) {\n                        dateFieldsPracticallyEqual = false;\n                    }\n                    rangePattern = rp;\n                }\n            }\n            else {\n                var rp = rangePatterns[fieldName];\n                if (rangePattern !== undefined && rp === undefined) {\n                    patternContainsLargerDateField = true;\n                }\n                else {\n                    var v1 = tm1[fieldName];\n                    var v2 = tm2[fieldName];\n                    if (!SameValue(v1, v2)) {\n                        dateFieldsPracticallyEqual = false;\n                    }\n                    rangePattern = rp;\n                }\n            }\n        }\n    }\n    if (dateFieldsPracticallyEqual) {\n        var result_2 = FormatDateTimePattern(dtf, PartitionPattern(pattern), x, implDetails);\n        for (var _a = 0, result_1 = result_2; _a < result_1.length; _a++) {\n            var r = result_1[_a];\n            r.source = RangePatternType.shared;\n        }\n        return result_2;\n    }\n    var result = [];\n    if (rangePattern === undefined) {\n        rangePattern = rangePatterns.default;\n        /** IMPL DETAILS */\n        // Now we have to replace {0} & {1} with actual pattern\n        for (var _b = 0, _c = rangePattern.patternParts; _b < _c.length; _b++) {\n            var patternPart = _c[_b];\n            if (patternPart.pattern === '{0}' || patternPart.pattern === '{1}') {\n                patternPart.pattern = pattern;\n            }\n        }\n    }\n    for (var _d = 0, _e = rangePattern.patternParts; _d < _e.length; _d++) {\n        var rangePatternPart = _e[_d];\n        var source = rangePatternPart.source, pattern_1 = rangePatternPart.pattern;\n        var z = void 0;\n        if (source === RangePatternType.startRange ||\n            source === RangePatternType.shared) {\n            z = x;\n        }\n        else {\n            z = y;\n        }\n        var patternParts = PartitionPattern(pattern_1);\n        var partResult = FormatDateTimePattern(dtf, patternParts, z, implDetails);\n        for (var _f = 0, partResult_1 = partResult; _f < partResult_1.length; _f++) {\n            var r = partResult_1[_f];\n            r.source = source;\n        }\n        result = result.concat(partResult);\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}