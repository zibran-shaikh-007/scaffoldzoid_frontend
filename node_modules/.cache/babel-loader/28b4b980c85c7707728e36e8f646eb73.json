{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar error_1 = require(\"./error\");\n\nvar types_1 = require(\"./types\");\n\nvar regex_generated_1 = require(\"./regex.generated\");\n\nvar icu_skeleton_parser_1 = require(\"@formatjs/icu-skeleton-parser\");\n\nfunction createLocation(start, end) {\n  return {\n    start: start,\n    end: end\n  };\n} // #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\n\n\nvar hasNativeStartsWith = !!String.prototype.startsWith;\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function (n) {\n  return typeof n === 'number' && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 0x1fffffffffffff;\n}; // IE11 does not support y and u.\n\nvar REGEX_SUPPORTS_U_AND_Y = true;\n\ntry {\n  RE('', 'yu');\n} catch (_) {\n  REGEX_SUPPORTS_U_AND_Y = false;\n}\n\nvar startsWith = hasNativeStartsWith ? // Native\nfunction startsWith(s, search, position) {\n  return s.startsWith(search, position);\n} : // For IE11\nfunction startsWith(s, search, position) {\n  return s.slice(position, position + search.length) === search;\n};\nvar fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : // IE11\nfunction fromCodePoint() {\n  var codePoints = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    codePoints[_i] = arguments[_i];\n  }\n\n  var elements = '';\n  var length = codePoints.length;\n  var i = 0;\n  var code;\n\n  while (length > i) {\n    code = codePoints[i++];\n    if (code > 0x10ffff) throw RangeError(code + ' is not a valid code point');\n    elements += code < 0x10000 ? String.fromCharCode(code) : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00);\n  }\n\n  return elements;\n};\nvar fromEntries = // native\nhasNativeFromEntries ? Object.fromEntries : // Ponyfill\nfunction fromEntries(entries) {\n  var obj = {};\n\n  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n    var _a = entries_1[_i],\n        k = _a[0],\n        v = _a[1];\n    obj[k] = v;\n  }\n\n  return obj;\n};\nvar codePointAt = hasNativeCodePointAt ? // Native\nfunction codePointAt(s, index) {\n  return s.codePointAt(index);\n} : // IE 11\nfunction codePointAt(s, index) {\n  var size = s.length;\n\n  if (index < 0 || index >= size) {\n    return undefined;\n  }\n\n  var first = s.charCodeAt(index);\n  var second;\n  return first < 0xd800 || first > 0xdbff || index + 1 === size || (second = s.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? first : (first - 0xd800 << 10) + (second - 0xdc00) + 0x10000;\n};\nvar trimStart = hasTrimStart ? // Native\nfunction trimStart(s) {\n  return s.trimStart();\n} : // Ponyfill\nfunction trimStart(s) {\n  return s.replace(regex_generated_1.SPACE_SEPARATOR_START_REGEX, '');\n};\nvar trimEnd = hasTrimEnd ? // Native\nfunction trimEnd(s) {\n  return s.trimEnd();\n} : // Ponyfill\nfunction trimEnd(s) {\n  return s.replace(regex_generated_1.SPACE_SEPARATOR_END_REGEX, '');\n}; // Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\n\nfunction RE(s, flag) {\n  return new RegExp(s, flag);\n} // #endregion\n\n\nvar matchIdentifierAtIndex;\n\nif (REGEX_SUPPORTS_U_AND_Y) {\n  // Native\n  var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var _a;\n\n    IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n    var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n    return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n  };\n} else {\n  // IE11\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var match = [];\n\n    while (true) {\n      var c = codePointAt(s, index);\n\n      if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n        break;\n      }\n\n      match.push(c);\n      index += c >= 0x10000 ? 2 : 1;\n    }\n\n    return fromCodePoint.apply(void 0, match);\n  };\n}\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(message, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.message = message;\n    this.position = {\n      offset: 0,\n      line: 1,\n      column: 1\n    };\n    this.ignoreTag = !!options.ignoreTag;\n    this.requiresOtherClause = !!options.requiresOtherClause;\n    this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n  }\n\n  Parser.prototype.parse = function () {\n    if (this.offset() !== 0) {\n      throw Error('parser can only be used once');\n    }\n\n    return this.parseMessage(0, '', false);\n  };\n\n  Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n    var elements = [];\n\n    while (!this.isEOF()) {\n      var char = this.char();\n\n      if (char === 123\n      /* `{` */\n      ) {\n          var result = this.parseArgument(nestingLevel, expectingCloseTag);\n\n          if (result.err) {\n            return result;\n          }\n\n          elements.push(result.val);\n        } else if (char === 125\n      /* `}` */\n      && nestingLevel > 0) {\n        break;\n      } else if (char === 35\n      /* `#` */\n      && (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n        var position = this.clonePosition();\n        this.bump();\n        elements.push({\n          type: types_1.TYPE.pound,\n          location: createLocation(position, this.clonePosition())\n        });\n      } else if (char === 60\n      /* `<` */\n      && !this.ignoreTag && this.peek() === 47 // char code for '/'\n      ) {\n          if (expectingCloseTag) {\n            break;\n          } else {\n            return this.error(error_1.ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n          }\n        } else if (char === 60\n      /* `<` */\n      && !this.ignoreTag && _isAlpha(this.peek() || 0)) {\n        var result = this.parseTag(nestingLevel, parentArgType);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      } else {\n        var result = this.parseLiteral(nestingLevel, parentArgType);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      }\n    }\n\n    return {\n      val: elements,\n      err: null\n    };\n  };\n  /**\n   * A tag name must start with an ASCII lower case letter. The grammar is based on the\n   * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\n   * are accepted:\n   *\n   * ```\n   * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\n   * tagName ::= [a-z] (PENChar)*\n   * PENChar ::=\n   *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\n   *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\n   *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n   * ```\n   *\n   * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n   */\n\n\n  Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n    var startPosition = this.clonePosition();\n    this.bump(); // `<`\n\n    var tagName = this.parseTagName();\n    this.bumpSpace();\n\n    if (this.bumpIf('/>')) {\n      // Self closing tag\n      return {\n        val: {\n          type: types_1.TYPE.literal,\n          value: \"<\" + tagName + \"/>\",\n          location: createLocation(startPosition, this.clonePosition())\n        },\n        err: null\n      };\n    } else if (this.bumpIf('>')) {\n      var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n\n      if (childrenResult.err) {\n        return childrenResult;\n      }\n\n      var children = childrenResult.val; // Expecting a close tag\n\n      var endTagStartPosition = this.clonePosition();\n\n      if (this.bumpIf('</')) {\n        if (this.isEOF() || !_isAlpha(this.char())) {\n          return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n\n        var closingTagNameStartPosition = this.clonePosition();\n        var closingTagName = this.parseTagName();\n\n        if (tagName !== closingTagName) {\n          return this.error(error_1.ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n        }\n\n        this.bumpSpace();\n\n        if (!this.bumpIf('>')) {\n          return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n\n        return {\n          val: {\n            type: types_1.TYPE.tag,\n            value: tagName,\n            children: children,\n            location: createLocation(startPosition, this.clonePosition())\n          },\n          err: null\n        };\n      } else {\n        return this.error(error_1.ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n      }\n    } else {\n      return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n    }\n  };\n  /**\n   * This method assumes that the caller has peeked ahead for the first tag character.\n   */\n\n\n  Parser.prototype.parseTagName = function () {\n    var startOffset = this.offset();\n    this.bump(); // the first tag name character\n\n    while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n      this.bump();\n    }\n\n    return this.message.slice(startOffset, this.offset());\n  };\n\n  Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n    var start = this.clonePosition();\n    var value = '';\n\n    while (true) {\n      var parseQuoteResult = this.tryParseQuote(parentArgType);\n\n      if (parseQuoteResult) {\n        value += parseQuoteResult;\n        continue;\n      }\n\n      var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n\n      if (parseUnquotedResult) {\n        value += parseUnquotedResult;\n        continue;\n      }\n\n      var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n\n      if (parseLeftAngleResult) {\n        value += parseLeftAngleResult;\n        continue;\n      }\n\n      break;\n    }\n\n    var location = createLocation(start, this.clonePosition());\n    return {\n      val: {\n        type: types_1.TYPE.literal,\n        value: value,\n        location: location\n      },\n      err: null\n    };\n  };\n\n  Parser.prototype.tryParseLeftAngleBracket = function () {\n    if (!this.isEOF() && this.char() === 60\n    /* `<` */\n    && (this.ignoreTag || // If at the opening tag or closing tag position, bail.\n    !_isAlphaOrSlash(this.peek() || 0))) {\n      this.bump(); // `<`\n\n      return '<';\n    }\n\n    return null;\n  };\n  /**\n   * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\n   * a character that requires quoting (that is, \"only where needed\"), and works the same in\n   * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\n   */\n\n\n  Parser.prototype.tryParseQuote = function (parentArgType) {\n    if (this.isEOF() || this.char() !== 39\n    /* `'` */\n    ) {\n        return null;\n      } // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n    // Check if is valid escaped character\n\n\n    switch (this.peek()) {\n      case 39\n      /* `'` */\n      :\n        // double quote, should return as a single quote.\n        this.bump();\n        this.bump();\n        return \"'\";\n      // '{', '<', '>', '}'\n\n      case 123:\n      case 60:\n      case 62:\n      case 125:\n        break;\n\n      case 35:\n        // '#'\n        if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n          break;\n        }\n\n        return null;\n\n      default:\n        return null;\n    }\n\n    this.bump(); // apostrophe\n\n    var codePoints = [this.char()]; // escaped char\n\n    this.bump(); // read chars until the optional closing apostrophe is found\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      if (ch === 39\n      /* `'` */\n      ) {\n          if (this.peek() === 39\n          /* `'` */\n          ) {\n              codePoints.push(39); // Bump one more time because we need to skip 2 characters.\n\n              this.bump();\n            } else {\n            // Optional closing apostrophe.\n            this.bump();\n            break;\n          }\n        } else {\n        codePoints.push(ch);\n      }\n\n      this.bump();\n    }\n\n    return fromCodePoint.apply(void 0, codePoints);\n  };\n\n  Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n    if (this.isEOF()) {\n      return null;\n    }\n\n    var ch = this.char();\n\n    if (ch === 60\n    /* `<` */\n    || ch === 123\n    /* `{` */\n    || ch === 35\n    /* `#` */\n    && (parentArgType === 'plural' || parentArgType === 'selectordinal') || ch === 125\n    /* `}` */\n    && nestingLevel > 0) {\n      return null;\n    } else {\n      this.bump();\n      return fromCodePoint(ch);\n    }\n  };\n\n  Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n    var openingBracePosition = this.clonePosition();\n    this.bump(); // `{`\n\n    this.bumpSpace();\n\n    if (this.isEOF()) {\n      return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    if (this.char() === 125\n    /* `}` */\n    ) {\n        this.bump();\n        return this.error(error_1.ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n      } // argument name\n\n\n    var value = this.parseIdentifierIfPossible().value;\n\n    if (!value) {\n      return this.error(error_1.ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    this.bumpSpace();\n\n    if (this.isEOF()) {\n      return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    switch (this.char()) {\n      // Simple argument: `{name}`\n      case 125\n      /* `}` */\n      :\n        {\n          this.bump(); // `}`\n\n          return {\n            val: {\n              type: types_1.TYPE.argument,\n              // value does not include the opening and closing braces.\n              value: value,\n              location: createLocation(openingBracePosition, this.clonePosition())\n            },\n            err: null\n          };\n        }\n      // Argument with options: `{name, format, ...}`\n\n      case 44\n      /* `,` */\n      :\n        {\n          this.bump(); // `,`\n\n          this.bumpSpace();\n\n          if (this.isEOF()) {\n            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n          }\n\n          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n        }\n\n      default:\n        return this.error(error_1.ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n  };\n  /**\n   * Advance the parser until the end of the identifier, if it is currently on\n   * an identifier character. Return an empty string otherwise.\n   */\n\n\n  Parser.prototype.parseIdentifierIfPossible = function () {\n    var startingPosition = this.clonePosition();\n    var startOffset = this.offset();\n    var value = matchIdentifierAtIndex(this.message, startOffset);\n    var endOffset = startOffset + value.length;\n    this.bumpTo(endOffset);\n    var endPosition = this.clonePosition();\n    var location = createLocation(startingPosition, endPosition);\n    return {\n      value: value,\n      location: location\n    };\n  };\n\n  Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n    var _a; // Parse this range:\n    // {name, type, style}\n    //        ^---^\n\n\n    var typeStartPosition = this.clonePosition();\n    var argType = this.parseIdentifierIfPossible().value;\n    var typeEndPosition = this.clonePosition();\n\n    switch (argType) {\n      case '':\n        // Expecting a style string number, date, time, plural, selectordinal, or select.\n        return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n\n      case 'number':\n      case 'date':\n      case 'time':\n        {\n          // Parse this range:\n          // {name, number, style}\n          //              ^-------^\n          this.bumpSpace();\n          var styleAndLocation = null;\n\n          if (this.bumpIf(',')) {\n            this.bumpSpace();\n            var styleStartPosition = this.clonePosition();\n            var result = this.parseSimpleArgStyleIfPossible();\n\n            if (result.err) {\n              return result;\n            }\n\n            var style = trimEnd(result.val);\n\n            if (style.length === 0) {\n              return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n\n            var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n            styleAndLocation = {\n              style: style,\n              styleLocation: styleLocation\n            };\n          }\n\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n\n          var location_1 = createLocation(openingBracePosition, this.clonePosition()); // Extract style or skeleton\n\n          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n            // Skeleton starts with `::`.\n            var skeleton = trimStart(styleAndLocation.style.slice(2));\n\n            if (argType === 'number') {\n              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n\n              if (result.err) {\n                return result;\n              }\n\n              return {\n                val: {\n                  type: types_1.TYPE.number,\n                  value: value,\n                  location: location_1,\n                  style: result.val\n                },\n                err: null\n              };\n            } else {\n              if (skeleton.length === 0) {\n                return this.error(error_1.ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n              }\n\n              var style = {\n                type: types_1.SKELETON_TYPE.dateTime,\n                pattern: skeleton,\n                location: styleAndLocation.styleLocation,\n                parsedOptions: this.shouldParseSkeletons ? icu_skeleton_parser_1.parseDateTimeSkeleton(skeleton) : {}\n              };\n              var type = argType === 'date' ? types_1.TYPE.date : types_1.TYPE.time;\n              return {\n                val: {\n                  type: type,\n                  value: value,\n                  location: location_1,\n                  style: style\n                },\n                err: null\n              };\n            }\n          } // Regular style or no style.\n\n\n          return {\n            val: {\n              type: argType === 'number' ? types_1.TYPE.number : argType === 'date' ? types_1.TYPE.date : types_1.TYPE.time,\n              value: value,\n              location: location_1,\n              style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null\n            },\n            err: null\n          };\n        }\n\n      case 'plural':\n      case 'selectordinal':\n      case 'select':\n        {\n          // Parse this range:\n          // {name, plural, options}\n          //              ^---------^\n          var typeEndPosition_1 = this.clonePosition();\n          this.bumpSpace();\n\n          if (!this.bumpIf(',')) {\n            return this.error(error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, tslib_1.__assign({}, typeEndPosition_1)));\n          }\n\n          this.bumpSpace(); // Parse offset:\n          // {name, plural, offset:1, options}\n          //                ^-----^\n          //\n          // or the first option:\n          //\n          // {name, plural, one {...} other {...}}\n          //                ^--^\n\n          var identifierAndLocation = this.parseIdentifierIfPossible();\n          var pluralOffset = 0;\n\n          if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n            if (!this.bumpIf(':')) {\n              return this.error(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n\n            this.bumpSpace();\n            var result = this.tryParseDecimalInteger(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, error_1.ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n\n            if (result.err) {\n              return result;\n            } // Parse another identifier for option parsing\n\n\n            this.bumpSpace();\n            identifierAndLocation = this.parseIdentifierIfPossible();\n            pluralOffset = result.val;\n          }\n\n          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n\n          if (optionsResult.err) {\n            return optionsResult;\n          }\n\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n\n          var location_2 = createLocation(openingBracePosition, this.clonePosition());\n\n          if (argType === 'select') {\n            return {\n              val: {\n                type: types_1.TYPE.select,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                location: location_2\n              },\n              err: null\n            };\n          } else {\n            return {\n              val: {\n                type: types_1.TYPE.plural,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                offset: pluralOffset,\n                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                location: location_2\n              },\n              err: null\n            };\n          }\n        }\n\n      default:\n        return this.error(error_1.ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n    }\n  };\n\n  Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n    // Parse: {value, number, ::currency/GBP }\n    //\n    if (this.isEOF() || this.char() !== 125\n    /* `}` */\n    ) {\n        return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n      }\n\n    this.bump(); // `}`\n\n    return {\n      val: true,\n      err: null\n    };\n  };\n  /**\n   * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\n   */\n\n\n  Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n    var nestedBraces = 0;\n    var startPosition = this.clonePosition();\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      switch (ch) {\n        case 39\n        /* `'` */\n        :\n          {\n            // Treat apostrophe as quoting but include it in the style part.\n            // Find the end of the quoted literal text.\n            this.bump();\n            var apostrophePosition = this.clonePosition();\n\n            if (!this.bumpUntil(\"'\")) {\n              return this.error(error_1.ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n            }\n\n            this.bump();\n            break;\n          }\n\n        case 123\n        /* `{` */\n        :\n          {\n            nestedBraces += 1;\n            this.bump();\n            break;\n          }\n\n        case 125\n        /* `}` */\n        :\n          {\n            if (nestedBraces > 0) {\n              nestedBraces -= 1;\n            } else {\n              return {\n                val: this.message.slice(startPosition.offset, this.offset()),\n                err: null\n              };\n            }\n\n            break;\n          }\n\n        default:\n          this.bump();\n          break;\n      }\n    }\n\n    return {\n      val: this.message.slice(startPosition.offset, this.offset()),\n      err: null\n    };\n  };\n\n  Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n    var tokens = [];\n\n    try {\n      tokens = icu_skeleton_parser_1.parseNumberSkeletonFromString(skeleton);\n    } catch (e) {\n      return this.error(error_1.ErrorKind.INVALID_NUMBER_SKELETON, location);\n    }\n\n    return {\n      val: {\n        type: types_1.SKELETON_TYPE.number,\n        tokens: tokens,\n        location: location,\n        parsedOptions: this.shouldParseSkeletons ? icu_skeleton_parser_1.parseNumberSkeleton(tokens) : {}\n      },\n      err: null\n    };\n  };\n  /**\n   * @param nesting_level The current nesting level of messages.\n   *     This can be positive when parsing message fragment in select or plural argument options.\n   * @param parent_arg_type The parent argument's type.\n   * @param parsed_first_identifier If provided, this is the first identifier-like selector of\n   *     the argument. It is a by-product of a previous parsing attempt.\n   * @param expecting_close_tag If true, this message is directly or indirectly nested inside\n   *     between a pair of opening and closing tags. The nested message will not parse beyond\n   *     the closing tag boundary.\n   */\n\n\n  Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n    var _a;\n\n    var hasOtherClause = false;\n    var options = [];\n    var parsedSelectors = new Set();\n    var selector = parsedFirstIdentifier.value,\n        selectorLocation = parsedFirstIdentifier.location; // Parse:\n    // one {one apple}\n    // ^--^\n\n    while (true) {\n      if (selector.length === 0) {\n        var startPosition = this.clonePosition();\n\n        if (parentArgType !== 'select' && this.bumpIf('=')) {\n          // Try parse `={number}` selector\n          var result = this.tryParseDecimalInteger(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, error_1.ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n\n          if (result.err) {\n            return result;\n          }\n\n          selectorLocation = createLocation(startPosition, this.clonePosition());\n          selector = this.message.slice(startPosition.offset, this.offset());\n        } else {\n          break;\n        }\n      } // Duplicate selector clauses\n\n\n      if (parsedSelectors.has(selector)) {\n        return this.error(parentArgType === 'select' ? error_1.ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : error_1.ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n      }\n\n      if (selector === 'other') {\n        hasOtherClause = true;\n      } // Parse:\n      // one {one apple}\n      //     ^----------^\n\n\n      this.bumpSpace();\n      var openingBracePosition = this.clonePosition();\n\n      if (!this.bumpIf('{')) {\n        return this.error(parentArgType === 'select' ? error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n      }\n\n      var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n\n      if (fragmentResult.err) {\n        return fragmentResult;\n      }\n\n      var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n      if (argCloseResult.err) {\n        return argCloseResult;\n      }\n\n      options.push([selector, {\n        value: fragmentResult.val,\n        location: createLocation(openingBracePosition, this.clonePosition())\n      }]); // Keep track of the existing selectors\n\n      parsedSelectors.add(selector); // Prep next selector clause.\n\n      this.bumpSpace();\n      _a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location;\n    }\n\n    if (options.length === 0) {\n      return this.error(parentArgType === 'select' ? error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n\n    if (this.requiresOtherClause && !hasOtherClause) {\n      return this.error(error_1.ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n\n    return {\n      val: options,\n      err: null\n    };\n  };\n\n  Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n    var sign = 1;\n    var startingPosition = this.clonePosition();\n\n    if (this.bumpIf('+')) {} else if (this.bumpIf('-')) {\n      sign = -1;\n    }\n\n    var hasDigits = false;\n    var decimal = 0;\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      if (ch >= 48\n      /* `0` */\n      && ch <= 57\n      /* `9` */\n      ) {\n          hasDigits = true;\n          decimal = decimal * 10 + (ch - 48);\n          this.bump();\n        } else {\n        break;\n      }\n    }\n\n    var location = createLocation(startingPosition, this.clonePosition());\n\n    if (!hasDigits) {\n      return this.error(expectNumberError, location);\n    }\n\n    decimal *= sign;\n\n    if (!isSafeInteger(decimal)) {\n      return this.error(invalidNumberError, location);\n    }\n\n    return {\n      val: decimal,\n      err: null\n    };\n  };\n\n  Parser.prototype.offset = function () {\n    return this.position.offset;\n  };\n\n  Parser.prototype.isEOF = function () {\n    return this.offset() === this.message.length;\n  };\n\n  Parser.prototype.clonePosition = function () {\n    // This is much faster than `Object.assign` or spread.\n    return {\n      offset: this.position.offset,\n      line: this.position.line,\n      column: this.position.column\n    };\n  };\n  /**\n   * Return the code point at the current position of the parser.\n   * Throws if the index is out of bound.\n   */\n\n\n  Parser.prototype.char = function () {\n    var offset = this.position.offset;\n\n    if (offset >= this.message.length) {\n      throw Error('out of bound');\n    }\n\n    var code = codePointAt(this.message, offset);\n\n    if (code === undefined) {\n      throw Error(\"Offset \" + offset + \" is at invalid UTF-16 code unit boundary\");\n    }\n\n    return code;\n  };\n\n  Parser.prototype.error = function (kind, location) {\n    return {\n      val: null,\n      err: {\n        kind: kind,\n        message: this.message,\n        location: location\n      }\n    };\n  };\n  /** Bump the parser to the next UTF-16 code unit. */\n\n\n  Parser.prototype.bump = function () {\n    if (this.isEOF()) {\n      return;\n    }\n\n    var code = this.char();\n\n    if (code === 10\n    /* '\\n' */\n    ) {\n        this.position.line += 1;\n        this.position.column = 1;\n        this.position.offset += 1;\n      } else {\n      this.position.column += 1; // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n\n      this.position.offset += code < 0x10000 ? 1 : 2;\n    }\n  };\n  /**\n   * If the substring starting at the current position of the parser has\n   * the given prefix, then bump the parser to the character immediately\n   * following the prefix and return true. Otherwise, don't bump the parser\n   * and return false.\n   */\n\n\n  Parser.prototype.bumpIf = function (prefix) {\n    if (startsWith(this.message, prefix, this.offset())) {\n      for (var i = 0; i < prefix.length; i++) {\n        this.bump();\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Bump the parser until the pattern character is found and return `true`.\n   * Otherwise bump to the end of the file and return `false`.\n   */\n\n\n  Parser.prototype.bumpUntil = function (pattern) {\n    var currentOffset = this.offset();\n    var index = this.message.indexOf(pattern, currentOffset);\n\n    if (index >= 0) {\n      this.bumpTo(index);\n      return true;\n    } else {\n      this.bumpTo(this.message.length);\n      return false;\n    }\n  };\n  /**\n   * Bump the parser to the target offset.\n   * If target offset is beyond the end of the input, bump the parser to the end of the input.\n   */\n\n\n  Parser.prototype.bumpTo = function (targetOffset) {\n    if (this.offset() > targetOffset) {\n      throw Error(\"targetOffset \" + targetOffset + \" must be greater than or equal to the current offset \" + this.offset());\n    }\n\n    targetOffset = Math.min(targetOffset, this.message.length);\n\n    while (true) {\n      var offset = this.offset();\n\n      if (offset === targetOffset) {\n        break;\n      }\n\n      if (offset > targetOffset) {\n        throw Error(\"targetOffset \" + targetOffset + \" is at invalid UTF-16 code unit boundary\");\n      }\n\n      this.bump();\n\n      if (this.isEOF()) {\n        break;\n      }\n    }\n  };\n  /** advance the parser through all whitespace to the next non-whitespace code unit. */\n\n\n  Parser.prototype.bumpSpace = function () {\n    while (!this.isEOF() && _isWhiteSpace(this.char())) {\n      this.bump();\n    }\n  };\n  /**\n   * Peek at the *next* Unicode codepoint in the input without advancing the parser.\n   * If the input has been exhausted, then this returns null.\n   */\n\n\n  Parser.prototype.peek = function () {\n    if (this.isEOF()) {\n      return null;\n    }\n\n    var code = this.char();\n    var offset = this.offset();\n    var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n    return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n  };\n\n  return Parser;\n}();\n\nexports.Parser = Parser;\n\nfunction _isAlpha(codepoint) {\n  return codepoint >= 97 && codepoint <= 122;\n}\n\nfunction _isAlphaOrSlash(codepoint) {\n  return _isAlpha(codepoint) || codepoint === 47;\n  /* '/' */\n}\n/** See `parseTag` function docs. */\n\n\nfunction _isPotentialElementNameChar(c) {\n  return c === 45\n  /* '-' */\n  || c === 46\n  /* '.' */\n  || c >= 48 && c <= 57\n  /* 0..9 */\n  || c === 95\n  /* '_' */\n  || c >= 97 && c <= 122\n  /** a..z */\n  || c >= 65 && c <= 90\n  /* A..Z */\n  || c == 0xb7 || c >= 0xc0 && c <= 0xd6 || c >= 0xd8 && c <= 0xf6 || c >= 0xf8 && c <= 0x37d || c >= 0x37f && c <= 0x1fff || c >= 0x200c && c <= 0x200d || c >= 0x203f && c <= 0x2040 || c >= 0x2070 && c <= 0x218f || c >= 0x2c00 && c <= 0x2fef || c >= 0x3001 && c <= 0xd7ff || c >= 0xf900 && c <= 0xfdcf || c >= 0xfdf0 && c <= 0xfffd || c >= 0x10000 && c <= 0xeffff;\n}\n/**\n * Code point equivalent of regex `\\p{White_Space}`.\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\n\n\nfunction _isWhiteSpace(c) {\n  return c >= 0x0009 && c <= 0x000d || c === 0x0020 || c === 0x0085 || c >= 0x200e && c <= 0x200f || c === 0x2028 || c === 0x2029;\n}\n/**\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\n\n\nfunction _isPatternSyntax(c) {\n  return c >= 0x0021 && c <= 0x0023 || c === 0x0024 || c >= 0x0025 && c <= 0x0027 || c === 0x0028 || c === 0x0029 || c === 0x002a || c === 0x002b || c === 0x002c || c === 0x002d || c >= 0x002e && c <= 0x002f || c >= 0x003a && c <= 0x003b || c >= 0x003c && c <= 0x003e || c >= 0x003f && c <= 0x0040 || c === 0x005b || c === 0x005c || c === 0x005d || c === 0x005e || c === 0x0060 || c === 0x007b || c === 0x007c || c === 0x007d || c === 0x007e || c === 0x00a1 || c >= 0x00a2 && c <= 0x00a5 || c === 0x00a6 || c === 0x00a7 || c === 0x00a9 || c === 0x00ab || c === 0x00ac || c === 0x00ae || c === 0x00b0 || c === 0x00b1 || c === 0x00b6 || c === 0x00bb || c === 0x00bf || c === 0x00d7 || c === 0x00f7 || c >= 0x2010 && c <= 0x2015 || c >= 0x2016 && c <= 0x2017 || c === 0x2018 || c === 0x2019 || c === 0x201a || c >= 0x201b && c <= 0x201c || c === 0x201d || c === 0x201e || c === 0x201f || c >= 0x2020 && c <= 0x2027 || c >= 0x2030 && c <= 0x2038 || c === 0x2039 || c === 0x203a || c >= 0x203b && c <= 0x203e || c >= 0x2041 && c <= 0x2043 || c === 0x2044 || c === 0x2045 || c === 0x2046 || c >= 0x2047 && c <= 0x2051 || c === 0x2052 || c === 0x2053 || c >= 0x2055 && c <= 0x205e || c >= 0x2190 && c <= 0x2194 || c >= 0x2195 && c <= 0x2199 || c >= 0x219a && c <= 0x219b || c >= 0x219c && c <= 0x219f || c === 0x21a0 || c >= 0x21a1 && c <= 0x21a2 || c === 0x21a3 || c >= 0x21a4 && c <= 0x21a5 || c === 0x21a6 || c >= 0x21a7 && c <= 0x21ad || c === 0x21ae || c >= 0x21af && c <= 0x21cd || c >= 0x21ce && c <= 0x21cf || c >= 0x21d0 && c <= 0x21d1 || c === 0x21d2 || c === 0x21d3 || c === 0x21d4 || c >= 0x21d5 && c <= 0x21f3 || c >= 0x21f4 && c <= 0x22ff || c >= 0x2300 && c <= 0x2307 || c === 0x2308 || c === 0x2309 || c === 0x230a || c === 0x230b || c >= 0x230c && c <= 0x231f || c >= 0x2320 && c <= 0x2321 || c >= 0x2322 && c <= 0x2328 || c === 0x2329 || c === 0x232a || c >= 0x232b && c <= 0x237b || c === 0x237c || c >= 0x237d && c <= 0x239a || c >= 0x239b && c <= 0x23b3 || c >= 0x23b4 && c <= 0x23db || c >= 0x23dc && c <= 0x23e1 || c >= 0x23e2 && c <= 0x2426 || c >= 0x2427 && c <= 0x243f || c >= 0x2440 && c <= 0x244a || c >= 0x244b && c <= 0x245f || c >= 0x2500 && c <= 0x25b6 || c === 0x25b7 || c >= 0x25b8 && c <= 0x25c0 || c === 0x25c1 || c >= 0x25c2 && c <= 0x25f7 || c >= 0x25f8 && c <= 0x25ff || c >= 0x2600 && c <= 0x266e || c === 0x266f || c >= 0x2670 && c <= 0x2767 || c === 0x2768 || c === 0x2769 || c === 0x276a || c === 0x276b || c === 0x276c || c === 0x276d || c === 0x276e || c === 0x276f || c === 0x2770 || c === 0x2771 || c === 0x2772 || c === 0x2773 || c === 0x2774 || c === 0x2775 || c >= 0x2794 && c <= 0x27bf || c >= 0x27c0 && c <= 0x27c4 || c === 0x27c5 || c === 0x27c6 || c >= 0x27c7 && c <= 0x27e5 || c === 0x27e6 || c === 0x27e7 || c === 0x27e8 || c === 0x27e9 || c === 0x27ea || c === 0x27eb || c === 0x27ec || c === 0x27ed || c === 0x27ee || c === 0x27ef || c >= 0x27f0 && c <= 0x27ff || c >= 0x2800 && c <= 0x28ff || c >= 0x2900 && c <= 0x2982 || c === 0x2983 || c === 0x2984 || c === 0x2985 || c === 0x2986 || c === 0x2987 || c === 0x2988 || c === 0x2989 || c === 0x298a || c === 0x298b || c === 0x298c || c === 0x298d || c === 0x298e || c === 0x298f || c === 0x2990 || c === 0x2991 || c === 0x2992 || c === 0x2993 || c === 0x2994 || c === 0x2995 || c === 0x2996 || c === 0x2997 || c === 0x2998 || c >= 0x2999 && c <= 0x29d7 || c === 0x29d8 || c === 0x29d9 || c === 0x29da || c === 0x29db || c >= 0x29dc && c <= 0x29fb || c === 0x29fc || c === 0x29fd || c >= 0x29fe && c <= 0x2aff || c >= 0x2b00 && c <= 0x2b2f || c >= 0x2b30 && c <= 0x2b44 || c >= 0x2b45 && c <= 0x2b46 || c >= 0x2b47 && c <= 0x2b4c || c >= 0x2b4d && c <= 0x2b73 || c >= 0x2b74 && c <= 0x2b75 || c >= 0x2b76 && c <= 0x2b95 || c === 0x2b96 || c >= 0x2b97 && c <= 0x2bff || c >= 0x2e00 && c <= 0x2e01 || c === 0x2e02 || c === 0x2e03 || c === 0x2e04 || c === 0x2e05 || c >= 0x2e06 && c <= 0x2e08 || c === 0x2e09 || c === 0x2e0a || c === 0x2e0b || c === 0x2e0c || c === 0x2e0d || c >= 0x2e0e && c <= 0x2e16 || c === 0x2e17 || c >= 0x2e18 && c <= 0x2e19 || c === 0x2e1a || c === 0x2e1b || c === 0x2e1c || c === 0x2e1d || c >= 0x2e1e && c <= 0x2e1f || c === 0x2e20 || c === 0x2e21 || c === 0x2e22 || c === 0x2e23 || c === 0x2e24 || c === 0x2e25 || c === 0x2e26 || c === 0x2e27 || c === 0x2e28 || c === 0x2e29 || c >= 0x2e2a && c <= 0x2e2e || c === 0x2e2f || c >= 0x2e30 && c <= 0x2e39 || c >= 0x2e3a && c <= 0x2e3b || c >= 0x2e3c && c <= 0x2e3f || c === 0x2e40 || c === 0x2e41 || c === 0x2e42 || c >= 0x2e43 && c <= 0x2e4f || c >= 0x2e50 && c <= 0x2e51 || c === 0x2e52 || c >= 0x2e53 && c <= 0x2e7f || c >= 0x3001 && c <= 0x3003 || c === 0x3008 || c === 0x3009 || c === 0x300a || c === 0x300b || c === 0x300c || c === 0x300d || c === 0x300e || c === 0x300f || c === 0x3010 || c === 0x3011 || c >= 0x3012 && c <= 0x3013 || c === 0x3014 || c === 0x3015 || c === 0x3016 || c === 0x3017 || c === 0x3018 || c === 0x3019 || c === 0x301a || c === 0x301b || c === 0x301c || c === 0x301d || c >= 0x301e && c <= 0x301f || c === 0x3020 || c === 0x3030 || c === 0xfd3e || c === 0xfd3f || c >= 0xfe45 && c <= 0xfe46;\n}","map":{"version":3,"sources":["/Users/zibranshaikh/Downloads/scaffoldzoid/frontend/node_modules/@formatjs/icu-messageformat-parser/parser.js"],"names":["Object","defineProperty","exports","value","Parser","tslib_1","require","error_1","types_1","regex_generated_1","icu_skeleton_parser_1","createLocation","start","end","hasNativeStartsWith","String","prototype","startsWith","hasNativeFromCodePoint","fromCodePoint","hasNativeFromEntries","fromEntries","hasNativeCodePointAt","codePointAt","hasTrimStart","trimStart","hasTrimEnd","trimEnd","hasNativeIsSafeInteger","Number","isSafeInteger","n","isFinite","Math","floor","abs","REGEX_SUPPORTS_U_AND_Y","RE","_","s","search","position","slice","length","codePoints","_i","arguments","elements","i","code","RangeError","fromCharCode","entries","obj","entries_1","_a","k","v","index","size","undefined","first","charCodeAt","second","replace","SPACE_SEPARATOR_START_REGEX","SPACE_SEPARATOR_END_REGEX","flag","RegExp","matchIdentifierAtIndex","IDENTIFIER_PREFIX_RE_1","lastIndex","match","exec","c","_isWhiteSpace","_isPatternSyntax","push","apply","message","options","offset","line","column","ignoreTag","requiresOtherClause","shouldParseSkeletons","parse","Error","parseMessage","nestingLevel","parentArgType","expectingCloseTag","isEOF","char","result","parseArgument","err","val","clonePosition","bump","type","TYPE","pound","location","peek","error","ErrorKind","UNMATCHED_CLOSING_TAG","_isAlpha","parseTag","parseLiteral","startPosition","tagName","parseTagName","bumpSpace","bumpIf","literal","childrenResult","children","endTagStartPosition","INVALID_TAG","closingTagNameStartPosition","closingTagName","tag","UNCLOSED_TAG","startOffset","_isPotentialElementNameChar","parseQuoteResult","tryParseQuote","parseUnquotedResult","tryParseUnquoted","parseLeftAngleResult","tryParseLeftAngleBracket","_isAlphaOrSlash","ch","openingBracePosition","EXPECT_ARGUMENT_CLOSING_BRACE","EMPTY_ARGUMENT","parseIdentifierIfPossible","MALFORMED_ARGUMENT","argument","parseArgumentOptions","startingPosition","endOffset","bumpTo","endPosition","typeStartPosition","argType","typeEndPosition","EXPECT_ARGUMENT_TYPE","styleAndLocation","styleStartPosition","parseSimpleArgStyleIfPossible","style","EXPECT_ARGUMENT_STYLE","styleLocation","argCloseResult","tryParseArgumentClose","location_1","skeleton","parseNumberSkeletonFromString","number","EXPECT_DATE_TIME_SKELETON","SKELETON_TYPE","dateTime","pattern","parsedOptions","parseDateTimeSkeleton","date","time","typeEndPosition_1","EXPECT_SELECT_ARGUMENT_OPTIONS","__assign","identifierAndLocation","pluralOffset","EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE","tryParseDecimalInteger","INVALID_PLURAL_ARGUMENT_OFFSET_VALUE","optionsResult","tryParsePluralOrSelectOptions","location_2","select","plural","pluralType","INVALID_ARGUMENT_TYPE","nestedBraces","apostrophePosition","bumpUntil","UNCLOSED_QUOTE_IN_ARGUMENT_STYLE","tokens","e","INVALID_NUMBER_SKELETON","parseNumberSkeleton","expectCloseTag","parsedFirstIdentifier","hasOtherClause","parsedSelectors","Set","selector","selectorLocation","EXPECT_PLURAL_ARGUMENT_SELECTOR","INVALID_PLURAL_ARGUMENT_SELECTOR","has","DUPLICATE_SELECT_ARGUMENT_SELECTOR","DUPLICATE_PLURAL_ARGUMENT_SELECTOR","EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT","EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT","fragmentResult","add","EXPECT_SELECT_ARGUMENT_SELECTOR","MISSING_OTHER_CLAUSE","expectNumberError","invalidNumberError","sign","hasDigits","decimal","kind","prefix","currentOffset","indexOf","targetOffset","min","nextCode","codepoint"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nvar tslib_1 = require(\"tslib\");\nvar error_1 = require(\"./error\");\nvar types_1 = require(\"./types\");\nvar regex_generated_1 = require(\"./regex.generated\");\nvar icu_skeleton_parser_1 = require(\"@formatjs/icu-skeleton-parser\");\nfunction createLocation(start, end) {\n    return { start: start, end: end };\n}\n// #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\nvar hasNativeStartsWith = !!String.prototype.startsWith;\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger\n    ? Number.isSafeInteger\n    : function (n) {\n        return (typeof n === 'number' &&\n            isFinite(n) &&\n            Math.floor(n) === n &&\n            Math.abs(n) <= 0x1fffffffffffff);\n    };\n// IE11 does not support y and u.\nvar REGEX_SUPPORTS_U_AND_Y = true;\ntry {\n    RE('', 'yu');\n}\ncatch (_) {\n    REGEX_SUPPORTS_U_AND_Y = false;\n}\nvar startsWith = hasNativeStartsWith\n    ? // Native\n        function startsWith(s, search, position) {\n            return s.startsWith(search, position);\n        }\n    : // For IE11\n        function startsWith(s, search, position) {\n            return s.slice(position, position + search.length) === search;\n        };\nvar fromCodePoint = hasNativeFromCodePoint\n    ? String.fromCodePoint\n    : // IE11\n        function fromCodePoint() {\n            var codePoints = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                codePoints[_i] = arguments[_i];\n            }\n            var elements = '';\n            var length = codePoints.length;\n            var i = 0;\n            var code;\n            while (length > i) {\n                code = codePoints[i++];\n                if (code > 0x10ffff)\n                    throw RangeError(code + ' is not a valid code point');\n                elements +=\n                    code < 0x10000\n                        ? String.fromCharCode(code)\n                        : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);\n            }\n            return elements;\n        };\nvar fromEntries = \n// native\nhasNativeFromEntries\n    ? Object.fromEntries\n    : // Ponyfill\n        function fromEntries(entries) {\n            var obj = {};\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\n                obj[k] = v;\n            }\n            return obj;\n        };\nvar codePointAt = hasNativeCodePointAt\n    ? // Native\n        function codePointAt(s, index) {\n            return s.codePointAt(index);\n        }\n    : // IE 11\n        function codePointAt(s, index) {\n            var size = s.length;\n            if (index < 0 || index >= size) {\n                return undefined;\n            }\n            var first = s.charCodeAt(index);\n            var second;\n            return first < 0xd800 ||\n                first > 0xdbff ||\n                index + 1 === size ||\n                (second = s.charCodeAt(index + 1)) < 0xdc00 ||\n                second > 0xdfff\n                ? first\n                : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;\n        };\nvar trimStart = hasTrimStart\n    ? // Native\n        function trimStart(s) {\n            return s.trimStart();\n        }\n    : // Ponyfill\n        function trimStart(s) {\n            return s.replace(regex_generated_1.SPACE_SEPARATOR_START_REGEX, '');\n        };\nvar trimEnd = hasTrimEnd\n    ? // Native\n        function trimEnd(s) {\n            return s.trimEnd();\n        }\n    : // Ponyfill\n        function trimEnd(s) {\n            return s.replace(regex_generated_1.SPACE_SEPARATOR_END_REGEX, '');\n        };\n// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\nfunction RE(s, flag) {\n    return new RegExp(s, flag);\n}\n// #endregion\nvar matchIdentifierAtIndex;\nif (REGEX_SUPPORTS_U_AND_Y) {\n    // Native\n    var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n        var _a;\n        IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n        var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n        return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n    };\n}\nelse {\n    // IE11\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n        var match = [];\n        while (true) {\n            var c = codePointAt(s, index);\n            if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n                break;\n            }\n            match.push(c);\n            index += c >= 0x10000 ? 2 : 1;\n        }\n        return fromCodePoint.apply(void 0, match);\n    };\n}\nvar Parser = /** @class */ (function () {\n    function Parser(message, options) {\n        if (options === void 0) { options = {}; }\n        this.message = message;\n        this.position = { offset: 0, line: 1, column: 1 };\n        this.ignoreTag = !!options.ignoreTag;\n        this.requiresOtherClause = !!options.requiresOtherClause;\n        this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n    }\n    Parser.prototype.parse = function () {\n        if (this.offset() !== 0) {\n            throw Error('parser can only be used once');\n        }\n        return this.parseMessage(0, '', false);\n    };\n    Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n        var elements = [];\n        while (!this.isEOF()) {\n            var char = this.char();\n            if (char === 123 /* `{` */) {\n                var result = this.parseArgument(nestingLevel, expectingCloseTag);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n            else if (char === 125 /* `}` */ && nestingLevel > 0) {\n                break;\n            }\n            else if (char === 35 /* `#` */ &&\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n                var position = this.clonePosition();\n                this.bump();\n                elements.push({\n                    type: types_1.TYPE.pound,\n                    location: createLocation(position, this.clonePosition()),\n                });\n            }\n            else if (char === 60 /* `<` */ &&\n                !this.ignoreTag &&\n                this.peek() === 47 // char code for '/'\n            ) {\n                if (expectingCloseTag) {\n                    break;\n                }\n                else {\n                    return this.error(error_1.ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n                }\n            }\n            else if (char === 60 /* `<` */ &&\n                !this.ignoreTag &&\n                _isAlpha(this.peek() || 0)) {\n                var result = this.parseTag(nestingLevel, parentArgType);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n            else {\n                var result = this.parseLiteral(nestingLevel, parentArgType);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n        }\n        return { val: elements, err: null };\n    };\n    /**\n     * A tag name must start with an ASCII lower case letter. The grammar is based on the\n     * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\n     * are accepted:\n     *\n     * ```\n     * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\n     * tagName ::= [a-z] (PENChar)*\n     * PENChar ::=\n     *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\n     *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\n     *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n     * ```\n     *\n     * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n     */\n    Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n        var startPosition = this.clonePosition();\n        this.bump(); // `<`\n        var tagName = this.parseTagName();\n        this.bumpSpace();\n        if (this.bumpIf('/>')) {\n            // Self closing tag\n            return {\n                val: {\n                    type: types_1.TYPE.literal,\n                    value: \"<\" + tagName + \"/>\",\n                    location: createLocation(startPosition, this.clonePosition()),\n                },\n                err: null,\n            };\n        }\n        else if (this.bumpIf('>')) {\n            var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n            if (childrenResult.err) {\n                return childrenResult;\n            }\n            var children = childrenResult.val;\n            // Expecting a close tag\n            var endTagStartPosition = this.clonePosition();\n            if (this.bumpIf('</')) {\n                if (this.isEOF() || !_isAlpha(this.char())) {\n                    return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n                }\n                var closingTagNameStartPosition = this.clonePosition();\n                var closingTagName = this.parseTagName();\n                if (tagName !== closingTagName) {\n                    return this.error(error_1.ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n                }\n                this.bumpSpace();\n                if (!this.bumpIf('>')) {\n                    return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n                }\n                return {\n                    val: {\n                        type: types_1.TYPE.tag,\n                        value: tagName,\n                        children: children,\n                        location: createLocation(startPosition, this.clonePosition()),\n                    },\n                    err: null,\n                };\n            }\n            else {\n                return this.error(error_1.ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n            }\n        }\n        else {\n            return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n        }\n    };\n    /**\n     * This method assumes that the caller has peeked ahead for the first tag character.\n     */\n    Parser.prototype.parseTagName = function () {\n        var startOffset = this.offset();\n        this.bump(); // the first tag name character\n        while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n            this.bump();\n        }\n        return this.message.slice(startOffset, this.offset());\n    };\n    Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n        var start = this.clonePosition();\n        var value = '';\n        while (true) {\n            var parseQuoteResult = this.tryParseQuote(parentArgType);\n            if (parseQuoteResult) {\n                value += parseQuoteResult;\n                continue;\n            }\n            var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n            if (parseUnquotedResult) {\n                value += parseUnquotedResult;\n                continue;\n            }\n            var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n            if (parseLeftAngleResult) {\n                value += parseLeftAngleResult;\n                continue;\n            }\n            break;\n        }\n        var location = createLocation(start, this.clonePosition());\n        return {\n            val: { type: types_1.TYPE.literal, value: value, location: location },\n            err: null,\n        };\n    };\n    Parser.prototype.tryParseLeftAngleBracket = function () {\n        if (!this.isEOF() &&\n            this.char() === 60 /* `<` */ &&\n            (this.ignoreTag ||\n                // If at the opening tag or closing tag position, bail.\n                !_isAlphaOrSlash(this.peek() || 0))) {\n            this.bump(); // `<`\n            return '<';\n        }\n        return null;\n    };\n    /**\n     * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\n     * a character that requires quoting (that is, \"only where needed\"), and works the same in\n     * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\n     */\n    Parser.prototype.tryParseQuote = function (parentArgType) {\n        if (this.isEOF() || this.char() !== 39 /* `'` */) {\n            return null;\n        }\n        // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n        // Check if is valid escaped character\n        switch (this.peek()) {\n            case 39 /* `'` */:\n                // double quote, should return as a single quote.\n                this.bump();\n                this.bump();\n                return \"'\";\n            // '{', '<', '>', '}'\n            case 123:\n            case 60:\n            case 62:\n            case 125:\n                break;\n            case 35: // '#'\n                if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n                    break;\n                }\n                return null;\n            default:\n                return null;\n        }\n        this.bump(); // apostrophe\n        var codePoints = [this.char()]; // escaped char\n        this.bump();\n        // read chars until the optional closing apostrophe is found\n        while (!this.isEOF()) {\n            var ch = this.char();\n            if (ch === 39 /* `'` */) {\n                if (this.peek() === 39 /* `'` */) {\n                    codePoints.push(39);\n                    // Bump one more time because we need to skip 2 characters.\n                    this.bump();\n                }\n                else {\n                    // Optional closing apostrophe.\n                    this.bump();\n                    break;\n                }\n            }\n            else {\n                codePoints.push(ch);\n            }\n            this.bump();\n        }\n        return fromCodePoint.apply(void 0, codePoints);\n    };\n    Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n        if (this.isEOF()) {\n            return null;\n        }\n        var ch = this.char();\n        if (ch === 60 /* `<` */ ||\n            ch === 123 /* `{` */ ||\n            (ch === 35 /* `#` */ &&\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||\n            (ch === 125 /* `}` */ && nestingLevel > 0)) {\n            return null;\n        }\n        else {\n            this.bump();\n            return fromCodePoint(ch);\n        }\n    };\n    Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n        var openingBracePosition = this.clonePosition();\n        this.bump(); // `{`\n        this.bumpSpace();\n        if (this.isEOF()) {\n            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        if (this.char() === 125 /* `}` */) {\n            this.bump();\n            return this.error(error_1.ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        // argument name\n        var value = this.parseIdentifierIfPossible().value;\n        if (!value) {\n            return this.error(error_1.ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        this.bumpSpace();\n        if (this.isEOF()) {\n            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        switch (this.char()) {\n            // Simple argument: `{name}`\n            case 125 /* `}` */: {\n                this.bump(); // `}`\n                return {\n                    val: {\n                        type: types_1.TYPE.argument,\n                        // value does not include the opening and closing braces.\n                        value: value,\n                        location: createLocation(openingBracePosition, this.clonePosition()),\n                    },\n                    err: null,\n                };\n            }\n            // Argument with options: `{name, format, ...}`\n            case 44 /* `,` */: {\n                this.bump(); // `,`\n                this.bumpSpace();\n                if (this.isEOF()) {\n                    return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n                }\n                return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n            }\n            default:\n                return this.error(error_1.ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n    };\n    /**\n     * Advance the parser until the end of the identifier, if it is currently on\n     * an identifier character. Return an empty string otherwise.\n     */\n    Parser.prototype.parseIdentifierIfPossible = function () {\n        var startingPosition = this.clonePosition();\n        var startOffset = this.offset();\n        var value = matchIdentifierAtIndex(this.message, startOffset);\n        var endOffset = startOffset + value.length;\n        this.bumpTo(endOffset);\n        var endPosition = this.clonePosition();\n        var location = createLocation(startingPosition, endPosition);\n        return { value: value, location: location };\n    };\n    Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n        var _a;\n        // Parse this range:\n        // {name, type, style}\n        //        ^---^\n        var typeStartPosition = this.clonePosition();\n        var argType = this.parseIdentifierIfPossible().value;\n        var typeEndPosition = this.clonePosition();\n        switch (argType) {\n            case '':\n                // Expecting a style string number, date, time, plural, selectordinal, or select.\n                return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n            case 'number':\n            case 'date':\n            case 'time': {\n                // Parse this range:\n                // {name, number, style}\n                //              ^-------^\n                this.bumpSpace();\n                var styleAndLocation = null;\n                if (this.bumpIf(',')) {\n                    this.bumpSpace();\n                    var styleStartPosition = this.clonePosition();\n                    var result = this.parseSimpleArgStyleIfPossible();\n                    if (result.err) {\n                        return result;\n                    }\n                    var style = trimEnd(result.val);\n                    if (style.length === 0) {\n                        return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n                    }\n                    var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n                    styleAndLocation = { style: style, styleLocation: styleLocation };\n                }\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n                if (argCloseResult.err) {\n                    return argCloseResult;\n                }\n                var location_1 = createLocation(openingBracePosition, this.clonePosition());\n                // Extract style or skeleton\n                if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n                    // Skeleton starts with `::`.\n                    var skeleton = trimStart(styleAndLocation.style.slice(2));\n                    if (argType === 'number') {\n                        var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n                        if (result.err) {\n                            return result;\n                        }\n                        return {\n                            val: { type: types_1.TYPE.number, value: value, location: location_1, style: result.val },\n                            err: null,\n                        };\n                    }\n                    else {\n                        if (skeleton.length === 0) {\n                            return this.error(error_1.ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n                        }\n                        var style = {\n                            type: types_1.SKELETON_TYPE.dateTime,\n                            pattern: skeleton,\n                            location: styleAndLocation.styleLocation,\n                            parsedOptions: this.shouldParseSkeletons\n                                ? icu_skeleton_parser_1.parseDateTimeSkeleton(skeleton)\n                                : {},\n                        };\n                        var type = argType === 'date' ? types_1.TYPE.date : types_1.TYPE.time;\n                        return {\n                            val: { type: type, value: value, location: location_1, style: style },\n                            err: null,\n                        };\n                    }\n                }\n                // Regular style or no style.\n                return {\n                    val: {\n                        type: argType === 'number'\n                            ? types_1.TYPE.number\n                            : argType === 'date'\n                                ? types_1.TYPE.date\n                                : types_1.TYPE.time,\n                        value: value,\n                        location: location_1,\n                        style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,\n                    },\n                    err: null,\n                };\n            }\n            case 'plural':\n            case 'selectordinal':\n            case 'select': {\n                // Parse this range:\n                // {name, plural, options}\n                //              ^---------^\n                var typeEndPosition_1 = this.clonePosition();\n                this.bumpSpace();\n                if (!this.bumpIf(',')) {\n                    return this.error(error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, tslib_1.__assign({}, typeEndPosition_1)));\n                }\n                this.bumpSpace();\n                // Parse offset:\n                // {name, plural, offset:1, options}\n                //                ^-----^\n                //\n                // or the first option:\n                //\n                // {name, plural, one {...} other {...}}\n                //                ^--^\n                var identifierAndLocation = this.parseIdentifierIfPossible();\n                var pluralOffset = 0;\n                if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n                    if (!this.bumpIf(':')) {\n                        return this.error(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n                    }\n                    this.bumpSpace();\n                    var result = this.tryParseDecimalInteger(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, error_1.ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n                    if (result.err) {\n                        return result;\n                    }\n                    // Parse another identifier for option parsing\n                    this.bumpSpace();\n                    identifierAndLocation = this.parseIdentifierIfPossible();\n                    pluralOffset = result.val;\n                }\n                var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n                if (optionsResult.err) {\n                    return optionsResult;\n                }\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n                if (argCloseResult.err) {\n                    return argCloseResult;\n                }\n                var location_2 = createLocation(openingBracePosition, this.clonePosition());\n                if (argType === 'select') {\n                    return {\n                        val: {\n                            type: types_1.TYPE.select,\n                            value: value,\n                            options: fromEntries(optionsResult.val),\n                            location: location_2,\n                        },\n                        err: null,\n                    };\n                }\n                else {\n                    return {\n                        val: {\n                            type: types_1.TYPE.plural,\n                            value: value,\n                            options: fromEntries(optionsResult.val),\n                            offset: pluralOffset,\n                            pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                            location: location_2,\n                        },\n                        err: null,\n                    };\n                }\n            }\n            default:\n                return this.error(error_1.ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n        }\n    };\n    Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n        // Parse: {value, number, ::currency/GBP }\n        //\n        if (this.isEOF() || this.char() !== 125 /* `}` */) {\n            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        this.bump(); // `}`\n        return { val: true, err: null };\n    };\n    /**\n     * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\n     */\n    Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n        var nestedBraces = 0;\n        var startPosition = this.clonePosition();\n        while (!this.isEOF()) {\n            var ch = this.char();\n            switch (ch) {\n                case 39 /* `'` */: {\n                    // Treat apostrophe as quoting but include it in the style part.\n                    // Find the end of the quoted literal text.\n                    this.bump();\n                    var apostrophePosition = this.clonePosition();\n                    if (!this.bumpUntil(\"'\")) {\n                        return this.error(error_1.ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n                    }\n                    this.bump();\n                    break;\n                }\n                case 123 /* `{` */: {\n                    nestedBraces += 1;\n                    this.bump();\n                    break;\n                }\n                case 125 /* `}` */: {\n                    if (nestedBraces > 0) {\n                        nestedBraces -= 1;\n                    }\n                    else {\n                        return {\n                            val: this.message.slice(startPosition.offset, this.offset()),\n                            err: null,\n                        };\n                    }\n                    break;\n                }\n                default:\n                    this.bump();\n                    break;\n            }\n        }\n        return {\n            val: this.message.slice(startPosition.offset, this.offset()),\n            err: null,\n        };\n    };\n    Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n        var tokens = [];\n        try {\n            tokens = icu_skeleton_parser_1.parseNumberSkeletonFromString(skeleton);\n        }\n        catch (e) {\n            return this.error(error_1.ErrorKind.INVALID_NUMBER_SKELETON, location);\n        }\n        return {\n            val: {\n                type: types_1.SKELETON_TYPE.number,\n                tokens: tokens,\n                location: location,\n                parsedOptions: this.shouldParseSkeletons\n                    ? icu_skeleton_parser_1.parseNumberSkeleton(tokens)\n                    : {},\n            },\n            err: null,\n        };\n    };\n    /**\n     * @param nesting_level The current nesting level of messages.\n     *     This can be positive when parsing message fragment in select or plural argument options.\n     * @param parent_arg_type The parent argument's type.\n     * @param parsed_first_identifier If provided, this is the first identifier-like selector of\n     *     the argument. It is a by-product of a previous parsing attempt.\n     * @param expecting_close_tag If true, this message is directly or indirectly nested inside\n     *     between a pair of opening and closing tags. The nested message will not parse beyond\n     *     the closing tag boundary.\n     */\n    Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n        var _a;\n        var hasOtherClause = false;\n        var options = [];\n        var parsedSelectors = new Set();\n        var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;\n        // Parse:\n        // one {one apple}\n        // ^--^\n        while (true) {\n            if (selector.length === 0) {\n                var startPosition = this.clonePosition();\n                if (parentArgType !== 'select' && this.bumpIf('=')) {\n                    // Try parse `={number}` selector\n                    var result = this.tryParseDecimalInteger(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, error_1.ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n                    if (result.err) {\n                        return result;\n                    }\n                    selectorLocation = createLocation(startPosition, this.clonePosition());\n                    selector = this.message.slice(startPosition.offset, this.offset());\n                }\n                else {\n                    break;\n                }\n            }\n            // Duplicate selector clauses\n            if (parsedSelectors.has(selector)) {\n                return this.error(parentArgType === 'select'\n                    ? error_1.ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR\n                    : error_1.ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n            }\n            if (selector === 'other') {\n                hasOtherClause = true;\n            }\n            // Parse:\n            // one {one apple}\n            //     ^----------^\n            this.bumpSpace();\n            var openingBracePosition = this.clonePosition();\n            if (!this.bumpIf('{')) {\n                return this.error(parentArgType === 'select'\n                    ? error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT\n                    : error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n            var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n            if (fragmentResult.err) {\n                return fragmentResult;\n            }\n            var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n            if (argCloseResult.err) {\n                return argCloseResult;\n            }\n            options.push([\n                selector,\n                {\n                    value: fragmentResult.val,\n                    location: createLocation(openingBracePosition, this.clonePosition()),\n                },\n            ]);\n            // Keep track of the existing selectors\n            parsedSelectors.add(selector);\n            // Prep next selector clause.\n            this.bumpSpace();\n            (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);\n        }\n        if (options.length === 0) {\n            return this.error(parentArgType === 'select'\n                ? error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR\n                : error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n        if (this.requiresOtherClause && !hasOtherClause) {\n            return this.error(error_1.ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n        return { val: options, err: null };\n    };\n    Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n        var sign = 1;\n        var startingPosition = this.clonePosition();\n        if (this.bumpIf('+')) {\n        }\n        else if (this.bumpIf('-')) {\n            sign = -1;\n        }\n        var hasDigits = false;\n        var decimal = 0;\n        while (!this.isEOF()) {\n            var ch = this.char();\n            if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {\n                hasDigits = true;\n                decimal = decimal * 10 + (ch - 48);\n                this.bump();\n            }\n            else {\n                break;\n            }\n        }\n        var location = createLocation(startingPosition, this.clonePosition());\n        if (!hasDigits) {\n            return this.error(expectNumberError, location);\n        }\n        decimal *= sign;\n        if (!isSafeInteger(decimal)) {\n            return this.error(invalidNumberError, location);\n        }\n        return { val: decimal, err: null };\n    };\n    Parser.prototype.offset = function () {\n        return this.position.offset;\n    };\n    Parser.prototype.isEOF = function () {\n        return this.offset() === this.message.length;\n    };\n    Parser.prototype.clonePosition = function () {\n        // This is much faster than `Object.assign` or spread.\n        return {\n            offset: this.position.offset,\n            line: this.position.line,\n            column: this.position.column,\n        };\n    };\n    /**\n     * Return the code point at the current position of the parser.\n     * Throws if the index is out of bound.\n     */\n    Parser.prototype.char = function () {\n        var offset = this.position.offset;\n        if (offset >= this.message.length) {\n            throw Error('out of bound');\n        }\n        var code = codePointAt(this.message, offset);\n        if (code === undefined) {\n            throw Error(\"Offset \" + offset + \" is at invalid UTF-16 code unit boundary\");\n        }\n        return code;\n    };\n    Parser.prototype.error = function (kind, location) {\n        return {\n            val: null,\n            err: {\n                kind: kind,\n                message: this.message,\n                location: location,\n            },\n        };\n    };\n    /** Bump the parser to the next UTF-16 code unit. */\n    Parser.prototype.bump = function () {\n        if (this.isEOF()) {\n            return;\n        }\n        var code = this.char();\n        if (code === 10 /* '\\n' */) {\n            this.position.line += 1;\n            this.position.column = 1;\n            this.position.offset += 1;\n        }\n        else {\n            this.position.column += 1;\n            // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n            this.position.offset += code < 0x10000 ? 1 : 2;\n        }\n    };\n    /**\n     * If the substring starting at the current position of the parser has\n     * the given prefix, then bump the parser to the character immediately\n     * following the prefix and return true. Otherwise, don't bump the parser\n     * and return false.\n     */\n    Parser.prototype.bumpIf = function (prefix) {\n        if (startsWith(this.message, prefix, this.offset())) {\n            for (var i = 0; i < prefix.length; i++) {\n                this.bump();\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Bump the parser until the pattern character is found and return `true`.\n     * Otherwise bump to the end of the file and return `false`.\n     */\n    Parser.prototype.bumpUntil = function (pattern) {\n        var currentOffset = this.offset();\n        var index = this.message.indexOf(pattern, currentOffset);\n        if (index >= 0) {\n            this.bumpTo(index);\n            return true;\n        }\n        else {\n            this.bumpTo(this.message.length);\n            return false;\n        }\n    };\n    /**\n     * Bump the parser to the target offset.\n     * If target offset is beyond the end of the input, bump the parser to the end of the input.\n     */\n    Parser.prototype.bumpTo = function (targetOffset) {\n        if (this.offset() > targetOffset) {\n            throw Error(\"targetOffset \" + targetOffset + \" must be greater than or equal to the current offset \" + this.offset());\n        }\n        targetOffset = Math.min(targetOffset, this.message.length);\n        while (true) {\n            var offset = this.offset();\n            if (offset === targetOffset) {\n                break;\n            }\n            if (offset > targetOffset) {\n                throw Error(\"targetOffset \" + targetOffset + \" is at invalid UTF-16 code unit boundary\");\n            }\n            this.bump();\n            if (this.isEOF()) {\n                break;\n            }\n        }\n    };\n    /** advance the parser through all whitespace to the next non-whitespace code unit. */\n    Parser.prototype.bumpSpace = function () {\n        while (!this.isEOF() && _isWhiteSpace(this.char())) {\n            this.bump();\n        }\n    };\n    /**\n     * Peek at the *next* Unicode codepoint in the input without advancing the parser.\n     * If the input has been exhausted, then this returns null.\n     */\n    Parser.prototype.peek = function () {\n        if (this.isEOF()) {\n            return null;\n        }\n        var code = this.char();\n        var offset = this.offset();\n        var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n        return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n    };\n    return Parser;\n}());\nexports.Parser = Parser;\nfunction _isAlpha(codepoint) {\n    return codepoint >= 97 && codepoint <= 122;\n}\nfunction _isAlphaOrSlash(codepoint) {\n    return _isAlpha(codepoint) || codepoint === 47; /* '/' */\n}\n/** See `parseTag` function docs. */\nfunction _isPotentialElementNameChar(c) {\n    return (c === 45 /* '-' */ ||\n        c === 46 /* '.' */ ||\n        (c >= 48 && c <= 57) /* 0..9 */ ||\n        c === 95 /* '_' */ ||\n        (c >= 97 && c <= 122) /** a..z */ ||\n        (c >= 65 && c <= 90) /* A..Z */ ||\n        c == 0xb7 ||\n        (c >= 0xc0 && c <= 0xd6) ||\n        (c >= 0xd8 && c <= 0xf6) ||\n        (c >= 0xf8 && c <= 0x37d) ||\n        (c >= 0x37f && c <= 0x1fff) ||\n        (c >= 0x200c && c <= 0x200d) ||\n        (c >= 0x203f && c <= 0x2040) ||\n        (c >= 0x2070 && c <= 0x218f) ||\n        (c >= 0x2c00 && c <= 0x2fef) ||\n        (c >= 0x3001 && c <= 0xd7ff) ||\n        (c >= 0xf900 && c <= 0xfdcf) ||\n        (c >= 0xfdf0 && c <= 0xfffd) ||\n        (c >= 0x10000 && c <= 0xeffff));\n}\n/**\n * Code point equivalent of regex `\\p{White_Space}`.\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\nfunction _isWhiteSpace(c) {\n    return ((c >= 0x0009 && c <= 0x000d) ||\n        c === 0x0020 ||\n        c === 0x0085 ||\n        (c >= 0x200e && c <= 0x200f) ||\n        c === 0x2028 ||\n        c === 0x2029);\n}\n/**\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\nfunction _isPatternSyntax(c) {\n    return ((c >= 0x0021 && c <= 0x0023) ||\n        c === 0x0024 ||\n        (c >= 0x0025 && c <= 0x0027) ||\n        c === 0x0028 ||\n        c === 0x0029 ||\n        c === 0x002a ||\n        c === 0x002b ||\n        c === 0x002c ||\n        c === 0x002d ||\n        (c >= 0x002e && c <= 0x002f) ||\n        (c >= 0x003a && c <= 0x003b) ||\n        (c >= 0x003c && c <= 0x003e) ||\n        (c >= 0x003f && c <= 0x0040) ||\n        c === 0x005b ||\n        c === 0x005c ||\n        c === 0x005d ||\n        c === 0x005e ||\n        c === 0x0060 ||\n        c === 0x007b ||\n        c === 0x007c ||\n        c === 0x007d ||\n        c === 0x007e ||\n        c === 0x00a1 ||\n        (c >= 0x00a2 && c <= 0x00a5) ||\n        c === 0x00a6 ||\n        c === 0x00a7 ||\n        c === 0x00a9 ||\n        c === 0x00ab ||\n        c === 0x00ac ||\n        c === 0x00ae ||\n        c === 0x00b0 ||\n        c === 0x00b1 ||\n        c === 0x00b6 ||\n        c === 0x00bb ||\n        c === 0x00bf ||\n        c === 0x00d7 ||\n        c === 0x00f7 ||\n        (c >= 0x2010 && c <= 0x2015) ||\n        (c >= 0x2016 && c <= 0x2017) ||\n        c === 0x2018 ||\n        c === 0x2019 ||\n        c === 0x201a ||\n        (c >= 0x201b && c <= 0x201c) ||\n        c === 0x201d ||\n        c === 0x201e ||\n        c === 0x201f ||\n        (c >= 0x2020 && c <= 0x2027) ||\n        (c >= 0x2030 && c <= 0x2038) ||\n        c === 0x2039 ||\n        c === 0x203a ||\n        (c >= 0x203b && c <= 0x203e) ||\n        (c >= 0x2041 && c <= 0x2043) ||\n        c === 0x2044 ||\n        c === 0x2045 ||\n        c === 0x2046 ||\n        (c >= 0x2047 && c <= 0x2051) ||\n        c === 0x2052 ||\n        c === 0x2053 ||\n        (c >= 0x2055 && c <= 0x205e) ||\n        (c >= 0x2190 && c <= 0x2194) ||\n        (c >= 0x2195 && c <= 0x2199) ||\n        (c >= 0x219a && c <= 0x219b) ||\n        (c >= 0x219c && c <= 0x219f) ||\n        c === 0x21a0 ||\n        (c >= 0x21a1 && c <= 0x21a2) ||\n        c === 0x21a3 ||\n        (c >= 0x21a4 && c <= 0x21a5) ||\n        c === 0x21a6 ||\n        (c >= 0x21a7 && c <= 0x21ad) ||\n        c === 0x21ae ||\n        (c >= 0x21af && c <= 0x21cd) ||\n        (c >= 0x21ce && c <= 0x21cf) ||\n        (c >= 0x21d0 && c <= 0x21d1) ||\n        c === 0x21d2 ||\n        c === 0x21d3 ||\n        c === 0x21d4 ||\n        (c >= 0x21d5 && c <= 0x21f3) ||\n        (c >= 0x21f4 && c <= 0x22ff) ||\n        (c >= 0x2300 && c <= 0x2307) ||\n        c === 0x2308 ||\n        c === 0x2309 ||\n        c === 0x230a ||\n        c === 0x230b ||\n        (c >= 0x230c && c <= 0x231f) ||\n        (c >= 0x2320 && c <= 0x2321) ||\n        (c >= 0x2322 && c <= 0x2328) ||\n        c === 0x2329 ||\n        c === 0x232a ||\n        (c >= 0x232b && c <= 0x237b) ||\n        c === 0x237c ||\n        (c >= 0x237d && c <= 0x239a) ||\n        (c >= 0x239b && c <= 0x23b3) ||\n        (c >= 0x23b4 && c <= 0x23db) ||\n        (c >= 0x23dc && c <= 0x23e1) ||\n        (c >= 0x23e2 && c <= 0x2426) ||\n        (c >= 0x2427 && c <= 0x243f) ||\n        (c >= 0x2440 && c <= 0x244a) ||\n        (c >= 0x244b && c <= 0x245f) ||\n        (c >= 0x2500 && c <= 0x25b6) ||\n        c === 0x25b7 ||\n        (c >= 0x25b8 && c <= 0x25c0) ||\n        c === 0x25c1 ||\n        (c >= 0x25c2 && c <= 0x25f7) ||\n        (c >= 0x25f8 && c <= 0x25ff) ||\n        (c >= 0x2600 && c <= 0x266e) ||\n        c === 0x266f ||\n        (c >= 0x2670 && c <= 0x2767) ||\n        c === 0x2768 ||\n        c === 0x2769 ||\n        c === 0x276a ||\n        c === 0x276b ||\n        c === 0x276c ||\n        c === 0x276d ||\n        c === 0x276e ||\n        c === 0x276f ||\n        c === 0x2770 ||\n        c === 0x2771 ||\n        c === 0x2772 ||\n        c === 0x2773 ||\n        c === 0x2774 ||\n        c === 0x2775 ||\n        (c >= 0x2794 && c <= 0x27bf) ||\n        (c >= 0x27c0 && c <= 0x27c4) ||\n        c === 0x27c5 ||\n        c === 0x27c6 ||\n        (c >= 0x27c7 && c <= 0x27e5) ||\n        c === 0x27e6 ||\n        c === 0x27e7 ||\n        c === 0x27e8 ||\n        c === 0x27e9 ||\n        c === 0x27ea ||\n        c === 0x27eb ||\n        c === 0x27ec ||\n        c === 0x27ed ||\n        c === 0x27ee ||\n        c === 0x27ef ||\n        (c >= 0x27f0 && c <= 0x27ff) ||\n        (c >= 0x2800 && c <= 0x28ff) ||\n        (c >= 0x2900 && c <= 0x2982) ||\n        c === 0x2983 ||\n        c === 0x2984 ||\n        c === 0x2985 ||\n        c === 0x2986 ||\n        c === 0x2987 ||\n        c === 0x2988 ||\n        c === 0x2989 ||\n        c === 0x298a ||\n        c === 0x298b ||\n        c === 0x298c ||\n        c === 0x298d ||\n        c === 0x298e ||\n        c === 0x298f ||\n        c === 0x2990 ||\n        c === 0x2991 ||\n        c === 0x2992 ||\n        c === 0x2993 ||\n        c === 0x2994 ||\n        c === 0x2995 ||\n        c === 0x2996 ||\n        c === 0x2997 ||\n        c === 0x2998 ||\n        (c >= 0x2999 && c <= 0x29d7) ||\n        c === 0x29d8 ||\n        c === 0x29d9 ||\n        c === 0x29da ||\n        c === 0x29db ||\n        (c >= 0x29dc && c <= 0x29fb) ||\n        c === 0x29fc ||\n        c === 0x29fd ||\n        (c >= 0x29fe && c <= 0x2aff) ||\n        (c >= 0x2b00 && c <= 0x2b2f) ||\n        (c >= 0x2b30 && c <= 0x2b44) ||\n        (c >= 0x2b45 && c <= 0x2b46) ||\n        (c >= 0x2b47 && c <= 0x2b4c) ||\n        (c >= 0x2b4d && c <= 0x2b73) ||\n        (c >= 0x2b74 && c <= 0x2b75) ||\n        (c >= 0x2b76 && c <= 0x2b95) ||\n        c === 0x2b96 ||\n        (c >= 0x2b97 && c <= 0x2bff) ||\n        (c >= 0x2e00 && c <= 0x2e01) ||\n        c === 0x2e02 ||\n        c === 0x2e03 ||\n        c === 0x2e04 ||\n        c === 0x2e05 ||\n        (c >= 0x2e06 && c <= 0x2e08) ||\n        c === 0x2e09 ||\n        c === 0x2e0a ||\n        c === 0x2e0b ||\n        c === 0x2e0c ||\n        c === 0x2e0d ||\n        (c >= 0x2e0e && c <= 0x2e16) ||\n        c === 0x2e17 ||\n        (c >= 0x2e18 && c <= 0x2e19) ||\n        c === 0x2e1a ||\n        c === 0x2e1b ||\n        c === 0x2e1c ||\n        c === 0x2e1d ||\n        (c >= 0x2e1e && c <= 0x2e1f) ||\n        c === 0x2e20 ||\n        c === 0x2e21 ||\n        c === 0x2e22 ||\n        c === 0x2e23 ||\n        c === 0x2e24 ||\n        c === 0x2e25 ||\n        c === 0x2e26 ||\n        c === 0x2e27 ||\n        c === 0x2e28 ||\n        c === 0x2e29 ||\n        (c >= 0x2e2a && c <= 0x2e2e) ||\n        c === 0x2e2f ||\n        (c >= 0x2e30 && c <= 0x2e39) ||\n        (c >= 0x2e3a && c <= 0x2e3b) ||\n        (c >= 0x2e3c && c <= 0x2e3f) ||\n        c === 0x2e40 ||\n        c === 0x2e41 ||\n        c === 0x2e42 ||\n        (c >= 0x2e43 && c <= 0x2e4f) ||\n        (c >= 0x2e50 && c <= 0x2e51) ||\n        c === 0x2e52 ||\n        (c >= 0x2e53 && c <= 0x2e7f) ||\n        (c >= 0x3001 && c <= 0x3003) ||\n        c === 0x3008 ||\n        c === 0x3009 ||\n        c === 0x300a ||\n        c === 0x300b ||\n        c === 0x300c ||\n        c === 0x300d ||\n        c === 0x300e ||\n        c === 0x300f ||\n        c === 0x3010 ||\n        c === 0x3011 ||\n        (c >= 0x3012 && c <= 0x3013) ||\n        c === 0x3014 ||\n        c === 0x3015 ||\n        c === 0x3016 ||\n        c === 0x3017 ||\n        c === 0x3018 ||\n        c === 0x3019 ||\n        c === 0x301a ||\n        c === 0x301b ||\n        c === 0x301c ||\n        c === 0x301d ||\n        (c >= 0x301e && c <= 0x301f) ||\n        c === 0x3020 ||\n        c === 0x3030 ||\n        c === 0xfd3e ||\n        c === 0xfd3f ||\n        (c >= 0xfe45 && c <= 0xfe46));\n}\n"]},"metadata":{},"sourceType":"script"}