{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseNumberSkeleton = exports.parseNumberSkeletonFromString = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar regex_generated_1 = require(\"./regex.generated\");\n\nfunction parseNumberSkeletonFromString(skeleton) {\n  if (skeleton.length === 0) {\n    throw new Error('Number skeleton cannot be empty');\n  } // Parse the skeleton\n\n\n  var stringTokens = skeleton.split(regex_generated_1.WHITE_SPACE_REGEX).filter(function (x) {\n    return x.length > 0;\n  });\n  var tokens = [];\n\n  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {\n    var stringToken = stringTokens_1[_i];\n    var stemAndOptions = stringToken.split('/');\n\n    if (stemAndOptions.length === 0) {\n      throw new Error('Invalid number skeleton');\n    }\n\n    var stem = stemAndOptions[0],\n        options = stemAndOptions.slice(1);\n\n    for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {\n      var option = options_1[_a];\n\n      if (option.length === 0) {\n        throw new Error('Invalid number skeleton');\n      }\n    }\n\n    tokens.push({\n      stem: stem,\n      options: options\n    });\n  }\n\n  return tokens;\n}\n\nexports.parseNumberSkeletonFromString = parseNumberSkeletonFromString;\n\nfunction icuUnitToEcma(unit) {\n  return unit.replace(/^(.*?)-/, '');\n}\n\nvar FRACTION_PRECISION_REGEX = /^\\.(?:(0+)(\\*)?|(#+)|(0+)(#+))$/g;\nvar SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\\+|#+)?$/g;\nvar INTEGER_WIDTH_REGEX = /(\\*)(0+)|(#+)(0+)|(0+)/g;\nvar CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;\n\nfunction parseSignificantPrecision(str) {\n  var result = {};\n  str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {\n    // @@@ case\n    if (typeof g2 !== 'string') {\n      result.minimumSignificantDigits = g1.length;\n      result.maximumSignificantDigits = g1.length;\n    } // @@@+ case\n    else if (g2 === '+') {\n        result.minimumSignificantDigits = g1.length;\n      } // .### case\n      else if (g1[0] === '#') {\n          result.maximumSignificantDigits = g1.length;\n        } // .@@## or .@@@ case\n        else {\n            result.minimumSignificantDigits = g1.length;\n            result.maximumSignificantDigits = g1.length + (typeof g2 === 'string' ? g2.length : 0);\n          }\n\n    return '';\n  });\n  return result;\n}\n\nfunction parseSign(str) {\n  switch (str) {\n    case 'sign-auto':\n      return {\n        signDisplay: 'auto'\n      };\n\n    case 'sign-accounting':\n    case '()':\n      return {\n        currencySign: 'accounting'\n      };\n\n    case 'sign-always':\n    case '+!':\n      return {\n        signDisplay: 'always'\n      };\n\n    case 'sign-accounting-always':\n    case '()!':\n      return {\n        signDisplay: 'always',\n        currencySign: 'accounting'\n      };\n\n    case 'sign-except-zero':\n    case '+?':\n      return {\n        signDisplay: 'exceptZero'\n      };\n\n    case 'sign-accounting-except-zero':\n    case '()?':\n      return {\n        signDisplay: 'exceptZero',\n        currencySign: 'accounting'\n      };\n\n    case 'sign-never':\n    case '+_':\n      return {\n        signDisplay: 'never'\n      };\n  }\n}\n\nfunction parseConciseScientificAndEngineeringStem(stem) {\n  // Engineering\n  var result;\n\n  if (stem[0] === 'E' && stem[1] === 'E') {\n    result = {\n      notation: 'engineering'\n    };\n    stem = stem.slice(2);\n  } else if (stem[0] === 'E') {\n    result = {\n      notation: 'scientific'\n    };\n    stem = stem.slice(1);\n  }\n\n  if (result) {\n    var signDisplay = stem.slice(0, 2);\n\n    if (signDisplay === '+!') {\n      result.signDisplay = 'always';\n      stem = stem.slice(2);\n    } else if (signDisplay === '+?') {\n      result.signDisplay = 'exceptZero';\n      stem = stem.slice(2);\n    }\n\n    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {\n      throw new Error('Malformed concise eng/scientific notation');\n    }\n\n    result.minimumIntegerDigits = stem.length;\n  }\n\n  return result;\n}\n\nfunction parseNotationOptions(opt) {\n  var result = {};\n  var signOpts = parseSign(opt);\n\n  if (signOpts) {\n    return signOpts;\n  }\n\n  return result;\n}\n/**\n * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options\n */\n\n\nfunction parseNumberSkeleton(tokens) {\n  var result = {};\n\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n\n    switch (token.stem) {\n      case 'percent':\n      case '%':\n        result.style = 'percent';\n        continue;\n\n      case '%x100':\n        result.style = 'percent';\n        result.scale = 100;\n        continue;\n\n      case 'currency':\n        result.style = 'currency';\n        result.currency = token.options[0];\n        continue;\n\n      case 'group-off':\n      case ',_':\n        result.useGrouping = false;\n        continue;\n\n      case 'precision-integer':\n      case '.':\n        result.maximumFractionDigits = 0;\n        continue;\n\n      case 'measure-unit':\n      case 'unit':\n        result.style = 'unit';\n        result.unit = icuUnitToEcma(token.options[0]);\n        continue;\n\n      case 'compact-short':\n      case 'K':\n        result.notation = 'compact';\n        result.compactDisplay = 'short';\n        continue;\n\n      case 'compact-long':\n      case 'KK':\n        result.notation = 'compact';\n        result.compactDisplay = 'long';\n        continue;\n\n      case 'scientific':\n        result = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, result), {\n          notation: 'scientific'\n        }), token.options.reduce(function (all, opt) {\n          return tslib_1.__assign(tslib_1.__assign({}, all), parseNotationOptions(opt));\n        }, {}));\n        continue;\n\n      case 'engineering':\n        result = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, result), {\n          notation: 'engineering'\n        }), token.options.reduce(function (all, opt) {\n          return tslib_1.__assign(tslib_1.__assign({}, all), parseNotationOptions(opt));\n        }, {}));\n        continue;\n\n      case 'notation-simple':\n        result.notation = 'standard';\n        continue;\n      // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h\n\n      case 'unit-width-narrow':\n        result.currencyDisplay = 'narrowSymbol';\n        result.unitDisplay = 'narrow';\n        continue;\n\n      case 'unit-width-short':\n        result.currencyDisplay = 'code';\n        result.unitDisplay = 'short';\n        continue;\n\n      case 'unit-width-full-name':\n        result.currencyDisplay = 'name';\n        result.unitDisplay = 'long';\n        continue;\n\n      case 'unit-width-iso-code':\n        result.currencyDisplay = 'symbol';\n        continue;\n\n      case 'scale':\n        result.scale = parseFloat(token.options[0]);\n        continue;\n      // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width\n\n      case 'integer-width':\n        if (token.options.length > 1) {\n          throw new RangeError('integer-width stems only accept a single optional option');\n        }\n\n        token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {\n          if (g1) {\n            result.minimumIntegerDigits = g2.length;\n          } else if (g3 && g4) {\n            throw new Error('We currently do not support maximum integer digits');\n          } else if (g5) {\n            throw new Error('We currently do not support exact integer digits');\n          }\n\n          return '';\n        });\n        continue;\n    } // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width\n\n\n    if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {\n      result.minimumIntegerDigits = token.stem.length;\n      continue;\n    }\n\n    if (FRACTION_PRECISION_REGEX.test(token.stem)) {\n      // Precision\n      // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision\n      // precision-integer case\n      if (token.options.length > 1) {\n        throw new RangeError('Fraction-precision stems only accept a single optional option');\n      }\n\n      token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {\n        // .000* case (before ICU67 it was .000+)\n        if (g2 === '*') {\n          result.minimumFractionDigits = g1.length;\n        } // .### case\n        else if (g3 && g3[0] === '#') {\n            result.maximumFractionDigits = g3.length;\n          } // .00## case\n          else if (g4 && g5) {\n              result.minimumFractionDigits = g4.length;\n              result.maximumFractionDigits = g4.length + g5.length;\n            } else {\n              result.minimumFractionDigits = g1.length;\n              result.maximumFractionDigits = g1.length;\n            }\n\n        return '';\n      });\n\n      if (token.options.length) {\n        result = tslib_1.__assign(tslib_1.__assign({}, result), parseSignificantPrecision(token.options[0]));\n      }\n\n      continue;\n    } // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision\n\n\n    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {\n      result = tslib_1.__assign(tslib_1.__assign({}, result), parseSignificantPrecision(token.stem));\n      continue;\n    }\n\n    var signOpts = parseSign(token.stem);\n\n    if (signOpts) {\n      result = tslib_1.__assign(tslib_1.__assign({}, result), signOpts);\n    }\n\n    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);\n\n    if (conciseScientificAndEngineeringOpts) {\n      result = tslib_1.__assign(tslib_1.__assign({}, result), conciseScientificAndEngineeringOpts);\n    }\n  }\n\n  return result;\n}\n\nexports.parseNumberSkeleton = parseNumberSkeleton;","map":{"version":3,"sources":["/Users/zibranshaikh/Downloads/scaffoldzoid/frontend/node_modules/@formatjs/icu-skeleton-parser/number.js"],"names":["Object","defineProperty","exports","value","parseNumberSkeleton","parseNumberSkeletonFromString","tslib_1","require","regex_generated_1","skeleton","length","Error","stringTokens","split","WHITE_SPACE_REGEX","filter","x","tokens","_i","stringTokens_1","stringToken","stemAndOptions","stem","options","slice","_a","options_1","option","push","icuUnitToEcma","unit","replace","FRACTION_PRECISION_REGEX","SIGNIFICANT_PRECISION_REGEX","INTEGER_WIDTH_REGEX","CONCISE_INTEGER_WIDTH_REGEX","parseSignificantPrecision","str","result","_","g1","g2","minimumSignificantDigits","maximumSignificantDigits","parseSign","signDisplay","currencySign","parseConciseScientificAndEngineeringStem","notation","test","minimumIntegerDigits","parseNotationOptions","opt","signOpts","tokens_1","token","style","scale","currency","useGrouping","maximumFractionDigits","compactDisplay","__assign","reduce","all","currencyDisplay","unitDisplay","parseFloat","RangeError","g3","g4","g5","minimumFractionDigits","conciseScientificAndEngineeringOpts"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseNumberSkeleton = exports.parseNumberSkeletonFromString = void 0;\nvar tslib_1 = require(\"tslib\");\nvar regex_generated_1 = require(\"./regex.generated\");\nfunction parseNumberSkeletonFromString(skeleton) {\n    if (skeleton.length === 0) {\n        throw new Error('Number skeleton cannot be empty');\n    }\n    // Parse the skeleton\n    var stringTokens = skeleton\n        .split(regex_generated_1.WHITE_SPACE_REGEX)\n        .filter(function (x) { return x.length > 0; });\n    var tokens = [];\n    for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {\n        var stringToken = stringTokens_1[_i];\n        var stemAndOptions = stringToken.split('/');\n        if (stemAndOptions.length === 0) {\n            throw new Error('Invalid number skeleton');\n        }\n        var stem = stemAndOptions[0], options = stemAndOptions.slice(1);\n        for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {\n            var option = options_1[_a];\n            if (option.length === 0) {\n                throw new Error('Invalid number skeleton');\n            }\n        }\n        tokens.push({ stem: stem, options: options });\n    }\n    return tokens;\n}\nexports.parseNumberSkeletonFromString = parseNumberSkeletonFromString;\nfunction icuUnitToEcma(unit) {\n    return unit.replace(/^(.*?)-/, '');\n}\nvar FRACTION_PRECISION_REGEX = /^\\.(?:(0+)(\\*)?|(#+)|(0+)(#+))$/g;\nvar SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\\+|#+)?$/g;\nvar INTEGER_WIDTH_REGEX = /(\\*)(0+)|(#+)(0+)|(0+)/g;\nvar CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;\nfunction parseSignificantPrecision(str) {\n    var result = {};\n    str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {\n        // @@@ case\n        if (typeof g2 !== 'string') {\n            result.minimumSignificantDigits = g1.length;\n            result.maximumSignificantDigits = g1.length;\n        }\n        // @@@+ case\n        else if (g2 === '+') {\n            result.minimumSignificantDigits = g1.length;\n        }\n        // .### case\n        else if (g1[0] === '#') {\n            result.maximumSignificantDigits = g1.length;\n        }\n        // .@@## or .@@@ case\n        else {\n            result.minimumSignificantDigits = g1.length;\n            result.maximumSignificantDigits =\n                g1.length + (typeof g2 === 'string' ? g2.length : 0);\n        }\n        return '';\n    });\n    return result;\n}\nfunction parseSign(str) {\n    switch (str) {\n        case 'sign-auto':\n            return {\n                signDisplay: 'auto',\n            };\n        case 'sign-accounting':\n        case '()':\n            return {\n                currencySign: 'accounting',\n            };\n        case 'sign-always':\n        case '+!':\n            return {\n                signDisplay: 'always',\n            };\n        case 'sign-accounting-always':\n        case '()!':\n            return {\n                signDisplay: 'always',\n                currencySign: 'accounting',\n            };\n        case 'sign-except-zero':\n        case '+?':\n            return {\n                signDisplay: 'exceptZero',\n            };\n        case 'sign-accounting-except-zero':\n        case '()?':\n            return {\n                signDisplay: 'exceptZero',\n                currencySign: 'accounting',\n            };\n        case 'sign-never':\n        case '+_':\n            return {\n                signDisplay: 'never',\n            };\n    }\n}\nfunction parseConciseScientificAndEngineeringStem(stem) {\n    // Engineering\n    var result;\n    if (stem[0] === 'E' && stem[1] === 'E') {\n        result = {\n            notation: 'engineering',\n        };\n        stem = stem.slice(2);\n    }\n    else if (stem[0] === 'E') {\n        result = {\n            notation: 'scientific',\n        };\n        stem = stem.slice(1);\n    }\n    if (result) {\n        var signDisplay = stem.slice(0, 2);\n        if (signDisplay === '+!') {\n            result.signDisplay = 'always';\n            stem = stem.slice(2);\n        }\n        else if (signDisplay === '+?') {\n            result.signDisplay = 'exceptZero';\n            stem = stem.slice(2);\n        }\n        if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {\n            throw new Error('Malformed concise eng/scientific notation');\n        }\n        result.minimumIntegerDigits = stem.length;\n    }\n    return result;\n}\nfunction parseNotationOptions(opt) {\n    var result = {};\n    var signOpts = parseSign(opt);\n    if (signOpts) {\n        return signOpts;\n    }\n    return result;\n}\n/**\n * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options\n */\nfunction parseNumberSkeleton(tokens) {\n    var result = {};\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        switch (token.stem) {\n            case 'percent':\n            case '%':\n                result.style = 'percent';\n                continue;\n            case '%x100':\n                result.style = 'percent';\n                result.scale = 100;\n                continue;\n            case 'currency':\n                result.style = 'currency';\n                result.currency = token.options[0];\n                continue;\n            case 'group-off':\n            case ',_':\n                result.useGrouping = false;\n                continue;\n            case 'precision-integer':\n            case '.':\n                result.maximumFractionDigits = 0;\n                continue;\n            case 'measure-unit':\n            case 'unit':\n                result.style = 'unit';\n                result.unit = icuUnitToEcma(token.options[0]);\n                continue;\n            case 'compact-short':\n            case 'K':\n                result.notation = 'compact';\n                result.compactDisplay = 'short';\n                continue;\n            case 'compact-long':\n            case 'KK':\n                result.notation = 'compact';\n                result.compactDisplay = 'long';\n                continue;\n            case 'scientific':\n                result = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, result), { notation: 'scientific' }), token.options.reduce(function (all, opt) { return (tslib_1.__assign(tslib_1.__assign({}, all), parseNotationOptions(opt))); }, {}));\n                continue;\n            case 'engineering':\n                result = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, result), { notation: 'engineering' }), token.options.reduce(function (all, opt) { return (tslib_1.__assign(tslib_1.__assign({}, all), parseNotationOptions(opt))); }, {}));\n                continue;\n            case 'notation-simple':\n                result.notation = 'standard';\n                continue;\n            // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h\n            case 'unit-width-narrow':\n                result.currencyDisplay = 'narrowSymbol';\n                result.unitDisplay = 'narrow';\n                continue;\n            case 'unit-width-short':\n                result.currencyDisplay = 'code';\n                result.unitDisplay = 'short';\n                continue;\n            case 'unit-width-full-name':\n                result.currencyDisplay = 'name';\n                result.unitDisplay = 'long';\n                continue;\n            case 'unit-width-iso-code':\n                result.currencyDisplay = 'symbol';\n                continue;\n            case 'scale':\n                result.scale = parseFloat(token.options[0]);\n                continue;\n            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width\n            case 'integer-width':\n                if (token.options.length > 1) {\n                    throw new RangeError('integer-width stems only accept a single optional option');\n                }\n                token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {\n                    if (g1) {\n                        result.minimumIntegerDigits = g2.length;\n                    }\n                    else if (g3 && g4) {\n                        throw new Error('We currently do not support maximum integer digits');\n                    }\n                    else if (g5) {\n                        throw new Error('We currently do not support exact integer digits');\n                    }\n                    return '';\n                });\n                continue;\n        }\n        // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width\n        if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {\n            result.minimumIntegerDigits = token.stem.length;\n            continue;\n        }\n        if (FRACTION_PRECISION_REGEX.test(token.stem)) {\n            // Precision\n            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision\n            // precision-integer case\n            if (token.options.length > 1) {\n                throw new RangeError('Fraction-precision stems only accept a single optional option');\n            }\n            token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {\n                // .000* case (before ICU67 it was .000+)\n                if (g2 === '*') {\n                    result.minimumFractionDigits = g1.length;\n                }\n                // .### case\n                else if (g3 && g3[0] === '#') {\n                    result.maximumFractionDigits = g3.length;\n                }\n                // .00## case\n                else if (g4 && g5) {\n                    result.minimumFractionDigits = g4.length;\n                    result.maximumFractionDigits = g4.length + g5.length;\n                }\n                else {\n                    result.minimumFractionDigits = g1.length;\n                    result.maximumFractionDigits = g1.length;\n                }\n                return '';\n            });\n            if (token.options.length) {\n                result = tslib_1.__assign(tslib_1.__assign({}, result), parseSignificantPrecision(token.options[0]));\n            }\n            continue;\n        }\n        // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision\n        if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {\n            result = tslib_1.__assign(tslib_1.__assign({}, result), parseSignificantPrecision(token.stem));\n            continue;\n        }\n        var signOpts = parseSign(token.stem);\n        if (signOpts) {\n            result = tslib_1.__assign(tslib_1.__assign({}, result), signOpts);\n        }\n        var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);\n        if (conciseScientificAndEngineeringOpts) {\n            result = tslib_1.__assign(tslib_1.__assign({}, result), conciseScientificAndEngineeringOpts);\n        }\n    }\n    return result;\n}\nexports.parseNumberSkeleton = parseNumberSkeleton;\n"]},"metadata":{},"sourceType":"script"}